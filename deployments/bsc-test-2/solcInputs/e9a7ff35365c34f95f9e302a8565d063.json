{
  "language": "Solidity",
  "sources": {
    "contracts/Baks.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./BaseToken.sol\";\n\ncontract Baks is BaseToken {\n    constructor(address minter) BaseToken(\"Baks\", \"BAKS\", 18, minter) {}\n}\n"
    },
    "contracts/BaseToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./interfaces/IEIP2612.sol\";\nimport {Governed} from \"./Governance.sol\";\nimport {IMintableAndBurnableERC20} from \"./interfaces/ERC20.sol\";\n\nerror ApproveFromZeroAddress(address spender, uint256 amount);\nerror ApproveToZeroAddress(address owner, uint256 amount);\n\nerror MintToZeroAddress(uint256 amount);\n\nerror BurnFromZeroAddress(uint256 amount);\nerror BurnAmountExceedsBalance(address from, uint256 amount, uint256 balance);\n\nerror TransferFromZeroAddress(address to, uint256 amount);\nerror TransferToZeroAddress(address from, uint256 amount);\nerror TransferAmountExceedsAllowance(address from, address to, uint256 amount, uint256 allowance);\nerror TransferAmountExceedsBalance(address from, address to, uint256 amount, uint256 balance);\n\nerror EIP2612PermissionExpired(uint256 deadline);\nerror EIP2612InvalidSignature(address owner, address signer);\n\nerror MinterZeroAddress();\nerror OnlyMinterAllowed();\n\ncontract BaseToken is Governed, IEIP2612, IMintableAndBurnableERC20 {\n    bytes32 private constant EIP_712_DOMAIN_TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    bytes32 private constant PERMIT_TYPE_HASH =\n        keccak256(\"Permit(address owner,address spender,uint256 amount,uint256 nonce,uint256 deadline)\");\n\n    string public override name;\n    string public override symbol;\n    uint8 public override decimals;\n    string public version;\n\n    address public minter;\n\n    uint256 public override totalSupply;\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 public override DOMAIN_SEPARATOR;\n    mapping(address => uint256) public override nonces;\n\n    event MinterChanged(address indexed minter, address indexed newMinter);\n\n    modifier onlyMinter() {\n        if (msg.sender != minter) {\n            revert OnlyMinterAllowed();\n        }\n        _;\n    }\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        address _minter\n    ) {\n        setGovernor(msg.sender);\n\n        if (_minter == address(0)) {\n            revert MinterZeroAddress();\n        }\n        minter = _minter;\n\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        version = \"1\";\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                EIP_712_DOMAIN_TYPE_HASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool) {\n        if (from != msg.sender) {\n            uint256 _allowance = allowance[from][msg.sender];\n            if (_allowance < amount) {\n                revert TransferAmountExceedsAllowance(from, to, amount, _allowance);\n            }\n        }\n\n        _transfer(from, to, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) external override returns (bool) {\n        _transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function mint(address to, uint256 amount) external override onlyMinter {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) external override onlyMinter {\n        _burn(from, amount);\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        if (deadline < block.timestamp) {\n            revert EIP2612PermissionExpired(deadline);\n        }\n\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPE_HASH, owner, spender, amount, nonces[owner]++, deadline))\n            )\n        );\n        address signer = ecrecover(hash, v, r, s);\n        if (signer != owner) {\n            revert EIP2612InvalidSignature(owner, signer);\n        }\n        _approve(owner, spender, amount);\n    }\n\n    function setMinter(address newMinter) external onlyGovernor {\n        if (newMinter == address(0)) {\n            revert MinterZeroAddress();\n        }\n        minter = newMinter;\n        emit MinterChanged(minter, newMinter);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal {\n        if (owner == address(0)) {\n            revert ApproveFromZeroAddress(spender, amount);\n        }\n        if (spender == address(0)) {\n            revert ApproveToZeroAddress(owner, amount);\n        }\n\n        allowance[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n    }\n\n    function _mint(address to, uint256 amount) internal {\n        if (to == address(0)) {\n            revert MintToZeroAddress(amount);\n        }\n\n        balanceOf[to] += amount;\n        totalSupply += amount;\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal {\n        if (from == address(0)) {\n            revert BurnFromZeroAddress(amount);\n        }\n\n        uint256 balance = balanceOf[from];\n        if (balance < amount) {\n            revert BurnAmountExceedsBalance(from, amount, balance);\n        }\n        unchecked {\n            balanceOf[from] = balance - amount;\n        }\n        totalSupply -= amount;\n\n        emit Transfer(from, address(0), amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (from == address(0)) {\n            revert TransferFromZeroAddress(to, amount);\n        }\n        if (to == address(0)) {\n            revert TransferToZeroAddress(from, amount);\n        }\n\n        uint256 balance = balanceOf[from];\n        if (balance < amount) {\n            revert TransferAmountExceedsBalance(from, to, amount, balance);\n        }\n        unchecked {\n            balanceOf[from] = balance - amount;\n        }\n        balanceOf[to] += amount;\n\n        emit Transfer(from, to, amount);\n    }\n}\n"
    },
    "contracts/interfaces/IEIP2612.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport {IERC20} from \"./ERC20.sol\";\n\ninterface IEIP2612 is IERC20 {\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n}\n"
    },
    "contracts/Governance.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nerror GovernedOnlyGovernorAllowedToCall();\nerror GovernedOnlyPendingGovernorAllowedToCall();\nerror GovernedGovernorZeroAddress();\nerror GovernedCantGoverItself();\n\nabstract contract Governed {\n    address public governor;\n    address public pendingGovernor;\n\n    event PendingGovernanceTransition(address indexed governor, address indexed newGovernor);\n    event GovernanceTransited(address indexed governor, address indexed newGovernor);\n\n    modifier onlyGovernor() {\n        if (msg.sender != governor) {\n            revert GovernedOnlyGovernorAllowedToCall();\n        }\n        _;\n    }\n\n    function transitGovernance(address newGovernor, bool force) external onlyGovernor {\n        if (newGovernor == address(0)) {\n            revert GovernedGovernorZeroAddress();\n        }\n        if (newGovernor == address(this)) {\n            revert GovernedCantGoverItself();\n        }\n\n        pendingGovernor = newGovernor;\n        if (!force) {\n            emit PendingGovernanceTransition(governor, newGovernor);\n        } else {\n            setGovernor(newGovernor);\n        }\n    }\n\n    function acceptGovernance() external {\n        if (msg.sender != pendingGovernor) {\n            revert GovernedOnlyPendingGovernorAllowedToCall();\n        }\n\n        governor = pendingGovernor;\n        emit GovernanceTransited(governor, pendingGovernor);\n    }\n\n    function setGovernor(address newGovernor) internal {\n        governor = newGovernor;\n        emit GovernanceTransited(governor, newGovernor);\n    }\n}\n"
    },
    "contracts/interfaces/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n\ninterface IMintableAndBurnableERC20 is IERC20 {\n    function mint(address to, uint256 amount) external;\n\n    function burn(address from, uint256 amount) external;\n}\n"
    },
    "contracts/Voice.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./BaseToken.sol\";\n\ncontract Voice is BaseToken {\n    constructor(address minter) BaseToken(\"BaksDAO Voice\", \"BDV\", 18, minter) {}\n}\n"
    },
    "contracts/test/WrappedNativeCurrency.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"./../BaseToken.sol\";\nimport \"./../interfaces/IWrappedNativeCurrency.sol\";\n\nerror WrappedNativeCurrencyLowLevelCallFailed();\n\ncontract WrappedNativeCurrency is BaseToken, IWrappedNativeCurrency {\n    constructor(address minter) BaseToken(\"Baks\", \"BAKS\", 18, minter) {}\n\n    function deposit() external payable override {\n        _mint(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) external override {\n        _burn(msg.sender, amount);\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        if (!success) {\n            revert WrappedNativeCurrencyLowLevelCallFailed();\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IWrappedNativeCurrency.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport {IERC20} from \"./ERC20.sol\";\n\ninterface IWrappedNativeCurrency is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256 amount) external;\n}\n"
    },
    "contracts/test/DummyPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.10;\n\nimport \"./../interfaces/IPriceOracle.sol\";\nimport \"./../libraries/FixedPointMath.sol\";\nimport {Governed} from \"./../Governance.sol\";\nimport {IERC20} from \"./../interfaces/ERC20.sol\";\nimport {Initializable} from \"./../libraries/Upgradability.sol\";\nimport {CoreInside, ICore} from \"./../Core.sol\";\n\ncontract DummyPriceOracle is CoreInside, Governed, Initializable, IPriceOracle {\n    mapping(IERC20 => uint256) public prices;\n\n    function initialize(ICore _core) external initializer {\n        initializeCoreInside(_core);\n        setGovernor(msg.sender);\n    }\n\n    function setPrice(IERC20 token, uint256 price) external onlyGovernor {\n        prices[token] = price;\n    }\n\n    function getNormalizedPrice(IERC20 token) external view override returns (uint256 normalizedPrice) {\n        normalizedPrice = prices[token];\n    }\n}\n"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport {IERC20} from \"./ERC20.sol\";\nimport \"./../libraries/FixedPointMath.sol\";\n\n/// @notice Thrown when oracle doesn't provide price for `token` token.\n/// @param token The address of the token contract.\nerror PriceOracleTokenUnknown(IERC20 token);\n/// @notice Thrown when oracle provide stale price `price` for `token` token.\n/// @param token The address of the token contract.\n/// @param price Provided price.\nerror PriceOracleStalePrice(IERC20 token, uint256 price);\n/// @notice Thrown when oracle provide negative, zero or in other ways invalid price `price` for `token` token.\n/// @param token The address of the token contract.\n/// @param price Provided price.\nerror PriceOracleInvalidPrice(IERC20 token, int256 price);\n\ninterface IPriceOracle {\n    /// @notice Gets normalized to 18 decimals price for the `token` token.\n    /// @param token The address of the token contract.\n    /// @return normalizedPrice Normalized price.\n    function getNormalizedPrice(IERC20 token) external view returns (uint256 normalizedPrice);\n}\n"
    },
    "contracts/libraries/FixedPointMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./Math.sol\";\n\nerror FixedPointMathMulDivOverflow(uint256 prod1, uint256 denominator);\nerror FixedPointMathExpArgumentTooBig(uint256 a);\nerror FixedPointMathExp2ArgumentTooBig(uint256 a);\nerror FixedPointMathLog2ArgumentTooBig(uint256 a);\n\n/// @title Fixed point math implementation\nlibrary FixedPointMath {\n    uint256 internal constant SCALE = 1e18;\n    uint256 internal constant HALF_SCALE = 5e17;\n    /// @dev Largest power of two divisor of scale.\n    uint256 internal constant SCALE_LPOTD = 262144;\n    /// @dev Scale inverted mod 2**256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661508869554232690281;\n    uint256 internal constant LOG2_E = 1_442695040888963407;\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert FixedPointMathMulDivOverflow(prod1, SCALE);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(a, b, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            assembly {\n                result := add(div(prod0, SCALE), roundUpUnit)\n            }\n            return result;\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256 result) {\n        result = mulDiv(a, SCALE, b);\n    }\n\n    /// @notice Calculates ⌊a × b ÷ denominator⌋ with full precision.\n    /// @dev Credit to Remco Bloemen under MIT license https://2π.com/21/muldiv.\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= denominator) {\n            revert FixedPointMathMulDivOverflow(prod1, denominator);\n        }\n\n        if (prod1 == 0) {\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        unchecked {\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, lpotdod)\n                prod0 := div(prod0, lpotdod)\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n            prod0 |= prod1 * lpotdod;\n\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n\n            result = prod0 * inverse;\n        }\n    }\n\n    function exp(uint256 x) internal pure returns (uint256 result) {\n        if (x >= 133_084258667509499441) {\n            revert FixedPointMathExpArgumentTooBig(x);\n        }\n\n        unchecked {\n            uint256 doubleScaleProduct = x * LOG2_E;\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\n        }\n    }\n\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        if (x >= 192e18) {\n            revert FixedPointMathExp2ArgumentTooBig(x);\n        }\n\n        unchecked {\n            x = (x << 64) / SCALE;\n\n            result = 0x800000000000000000000000000000000000000000000000;\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n\n            result *= SCALE;\n            result >>= (191 - (x >> 64));\n        }\n    }\n\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            result = y == 0 ? SCALE : uint256(0);\n        } else {\n            result = exp2(mul(log2(x), y));\n        }\n    }\n\n    function log2(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert FixedPointMathLog2ArgumentTooBig(x);\n        }\n        unchecked {\n            uint256 n = Math.mostSignificantBit(x / SCALE);\n\n            result = n * SCALE;\n\n            uint256 y = x >> n;\n\n            if (y == SCALE) {\n                return result;\n            }\n\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\n                y = (y * y) / SCALE;\n\n                if (y >= 2 * SCALE) {\n                    result += delta;\n\n                    y >>= 1;\n                }\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/Upgradability.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./Address.sol\";\n\nerror EIP1967ImplementationIsNotContract(address implementation);\nerror ContractAlreadyInitialized();\nerror OnlyProxyCallAllowed();\nerror OnlyCurrentImplementationAllowed();\n\nlibrary EIP1967 {\n    using Address for address;\n\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    event Upgraded(address indexed newImplementation);\n\n    function upgradeTo(address newImplementation) internal {\n        if (!newImplementation.isContract()) {\n            revert EIP1967ImplementationIsNotContract(newImplementation);\n        }\n\n        assembly {\n            sstore(IMPLEMENTATION_SLOT, newImplementation)\n        }\n\n        emit Upgraded(newImplementation);\n    }\n\n    function getImplementation() internal view returns (address implementation) {\n        assembly {\n            implementation := sload(IMPLEMENTATION_SLOT)\n        }\n    }\n}\n\ncontract Proxy {\n    using Address for address;\n\n    constructor(address implementation, bytes memory data) {\n        EIP1967.upgradeTo(implementation);\n        implementation.delegateCall(data, \"Proxy: construction failed\");\n    }\n\n    receive() external payable {\n        delegateCall();\n    }\n\n    fallback() external payable {\n        delegateCall();\n    }\n\n    function delegateCall() internal {\n        address implementation = EIP1967.getImplementation();\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n\nabstract contract Upgradeable {\n    address private immutable self = address(this);\n\n    modifier onlyProxy() {\n        if (address(this) == self) {\n            revert OnlyProxyCallAllowed();\n        }\n        if (EIP1967.getImplementation() != self) {\n            revert OnlyCurrentImplementationAllowed();\n        }\n        _;\n    }\n\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        EIP1967.upgradeTo(newImplementation);\n    }\n}\n\nabstract contract Initializable {\n    bool private initializing;\n    bool private initialized;\n\n    modifier initializer() {\n        if (!initializing && initialized) {\n            revert ContractAlreadyInitialized();\n        }\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n}\n"
    },
    "contracts/Core.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {Governed} from \"./Governance.sol\";\nimport {Initializable} from \"./libraries/Upgradability.sol\";\n\ninterface ICore {\n    /// @dev Thrown when trying to set platform fees that don't sum up to one.\n    /// @param stabilizationFee The stabilization fee that was tried to set.\n    /// @param exchangeFee The stabilization fee that was tried to set.\n    /// @param developmentFee The stabilization fee that was tried to set.\n    error BaksDAOPlatformFeesDontSumUpToOne(uint256 stabilizationFee, uint256 exchangeFee, uint256 developmentFee);\n\n    event PriceOracleUpdated(address priceOracle, address newPriceOracle);\n\n    event BaksUpdated(address baks, address newBaks);\n    event VoiceUpdated(address voice, address newVoice);\n\n    event BankUpdated(address bank, address newBank);\n    event DepositaryUpdated(address depositary, address newDepositary);\n    event ExchangeFundUpdated(address exchangeFund, address newExchangeFund);\n    event DevelopmentFundUpdated(address developmentFund, address newDevelopmentFund);\n\n    event OperatorUpdated(address operator, address newOperator);\n    event LiquidatorUpdated(address liquidator, address newLiquidator);\n\n    event InterestUpdated(uint256 interest, uint256 newInterest);\n    event MinimumPrincipalAmountUpdated(uint256 minimumPrincipalAmount, uint256 newMinimumPrincipalAmount);\n    event StabilityFeeUpdated(uint256 stabilityFee, uint256 newStabilityFee);\n    event RebalancingThresholdUpdated(uint256 rebalancingThreshold, uint256 newRebalancingThreshold);\n    event PlatformFeesUpdated(\n        uint256 stabilizationFee,\n        uint256 newStabilizationFee,\n        uint256 exchangeFee,\n        uint256 newExchangeFee,\n        uint256 developmentFee,\n        uint256 newDevelopmentFee\n    );\n    event MarginCallLoanToValueRatioUpdated(uint256 marginCallLoanToValueRatio, uint256 newMarginCallLoanToValueRatio);\n    event LiquidationLoanToValueRatioUpdated(\n        uint256 liqudationLoanToValueRatio,\n        uint256 newLiquidationLoanToValueRatio\n    );\n\n    event MinimumMagisterDepositAmountUpdated(\n        uint256 minimumMagisterDepositAmount,\n        uint256 newMinimumMagisterDepositAmount\n    );\n    event WorkFeeUpdated(uint256 workFee, uint256 newWorkFee);\n    event EarlyWithdrawalPeriodUpdated(uint256 earlyWithdrawalPeriod, uint256 newEarlyWithdrawalPeriod);\n    event EarlyWithdrawalFeeUpdated(uint256 earlyWithdrawalFee, uint256 newEarlyWithdrawalFee);\n\n    event ServicingThresholdUpdated(uint256 servicingThreshold, uint256 newServicingThreshold);\n    event MinimumLiquidityUpdated(uint256 minimumLiquidity, uint256 newMinimumLiquidity);\n\n    function wrappedNativeCurrency() external view returns (address);\n\n    function uniswapV2Router() external view returns (address);\n\n    function priceOracle() external view returns (address);\n\n    function baks() external view returns (address);\n\n    function voice() external view returns (address);\n\n    function bank() external view returns (address);\n\n    function depositary() external view returns (address);\n\n    function exchangeFund() external view returns (address);\n\n    function developmentFund() external view returns (address);\n\n    function operator() external view returns (address);\n\n    function liquidator() external view returns (address);\n\n    function interest() external view returns (uint256);\n\n    function minimumPrincipalAmount() external view returns (uint256);\n\n    function stabilityFee() external view returns (uint256);\n\n    function stabilizationFee() external view returns (uint256);\n\n    function exchangeFee() external view returns (uint256);\n\n    function developmentFee() external view returns (uint256);\n\n    function marginCallLoanToValueRatio() external view returns (uint256);\n\n    function liquidationLoanToValueRatio() external view returns (uint256);\n\n    function rebalancingThreshold() external view returns (uint256);\n\n    function minimumMagisterDepositAmount() external view returns (uint256);\n\n    function workFee() external view returns (uint256);\n\n    function earlyWithdrawalPeriod() external view returns (uint256);\n\n    function earlyWithdrawalFee() external view returns (uint256);\n\n    function servicingThreshold() external view returns (uint256);\n\n    function minimumLiquidity() external view returns (uint256);\n\n    function voiceMintingSchedule() external view returns (uint256[] memory);\n}\n\ncontract Core is Initializable, Governed, ICore {\n    uint256 internal constant ONE = 100e16;\n\n    address public override wrappedNativeCurrency;\n    address public override uniswapV2Router;\n\n    address public override priceOracle;\n\n    address public override baks;\n    address public override voice;\n\n    address public override bank;\n    address public override depositary;\n    address public override exchangeFund;\n    address public override developmentFund;\n\n    // Roles\n    address public override operator;\n    address public override liquidator;\n\n    // Bank parameters\n    uint256 public override interest;\n    uint256 public override minimumPrincipalAmount;\n    uint256 public override stabilityFee;\n    uint256 public override stabilizationFee;\n    uint256 public override exchangeFee;\n    uint256 public override developmentFee;\n    uint256 public override marginCallLoanToValueRatio;\n    uint256 public override liquidationLoanToValueRatio;\n    uint256 public override rebalancingThreshold;\n\n    // Depositary parameters\n    uint256 public override minimumMagisterDepositAmount;\n    uint256 public override workFee;\n    uint256 public override earlyWithdrawalPeriod;\n    uint256 public override earlyWithdrawalFee;\n\n    // Exchange fund parameters\n    uint256 public override servicingThreshold;\n    uint256 public override minimumLiquidity;\n\n    // Voice\n    uint256[] internal _voiceMintingSchedule;\n\n    function initialize(\n        address _wrappedNativeCurrency,\n        address _uniswapV2Router,\n        address _operator,\n        address _liquidator\n    ) external initializer {\n        setGovernor(msg.sender);\n\n        wrappedNativeCurrency = _wrappedNativeCurrency;\n        uniswapV2Router = _uniswapV2Router;\n\n        operator = _operator;\n        liquidator = _liquidator;\n\n        interest = 11e16; // 11 %\n        minimumPrincipalAmount = 50e18; // 50 BAKS\n        stabilityFee = 15e15; // 1,5 %\n        stabilizationFee = 85e16; // 85 %\n        exchangeFee = 15e16; // 15 %\n        developmentFee = 0;\n        marginCallLoanToValueRatio = 75e16; // 75 %\n        liquidationLoanToValueRatio = 83e16; // 83 %\n        rebalancingThreshold = 1e16; // 1 %\n\n        minimumMagisterDepositAmount = 50000e18; // 50000 BAKS\n        workFee = 2e16; // 2 %\n        earlyWithdrawalPeriod = 72 hours;\n        earlyWithdrawalFee = 1e15; // 0,1 %\n\n        servicingThreshold = 1e16; // 1%\n        minimumLiquidity = 50000e18; // 50000 BAKS\n\n        _voiceMintingSchedule = [\n            0x295be96e64066972000000,\n            0x0422ca8b0a00a4250000000000000000295be96e64066972000000,\n            0x084595161401484a000000000000000052b7d2dcc80cd2e4000000,\n            0x108b2a2c28029094000000000000000052b7d2dcc80cd2e4000000,\n            0x2116545850052128000000000000000052b7d2dcc80cd2e4000000,\n            0x422ca8b0a00a4250000000000000000052b7d2dcc80cd2e4000000,\n            0x84595161401484a0000000000000000052b7d2dcc80cd2e4000000,\n            0x0108b2a2c280290940000000000000000052b7d2dcc80cd2e4000000,\n            0x014adf4b7320334b90000000000000000052b7d2dcc80cd2e4000000,\n            0x018d0bf423c03d8de0000000000000000052b7d2dcc80cd2e4000000,\n            0x01cf389cd46047d030000000000000000052b7d2dcc80cd2e4000000,\n            0x021165458500521280000000000000000052b7d2dcc80cd2e4000000,\n            0x025391ee35a05c54d0000000000000000052b7d2dcc80cd2e4000000,\n            0x0295be96e6406697200000000000000000a56fa5b99019a5c8000000,\n            0x02d7eb3f96e070d9700000000000000000a56fa5b99019a5c8000000,\n            0x031a17e847807b1bc00000000000000000a56fa5b99019a5c8000000,\n            0x035c4490f820855e100000000000000000a56fa5b99019a5c8000000\n        ];\n    }\n\n    function setPriceOracle(address newPriceOracle) external onlyGovernor {\n        emit PriceOracleUpdated(priceOracle, newPriceOracle);\n        priceOracle = newPriceOracle;\n    }\n\n    function setBaks(address newBaks) external onlyGovernor {\n        emit BaksUpdated(baks, newBaks);\n        baks = newBaks;\n    }\n\n    function setVoice(address newVoice) external onlyGovernor {\n        emit VoiceUpdated(voice, newVoice);\n        voice = newVoice;\n    }\n\n    function setBank(address newBank) external onlyGovernor {\n        emit BankUpdated(bank, newBank);\n        bank = newBank;\n    }\n\n    function setDepositary(address newDepositary) external onlyGovernor {\n        emit DepositaryUpdated(depositary, newDepositary);\n        depositary = newDepositary;\n    }\n\n    function setExchangeFund(address newExchangeFund) external onlyGovernor {\n        emit ExchangeFundUpdated(exchangeFund, newExchangeFund);\n        exchangeFund = newExchangeFund;\n    }\n\n    function setDevelopmentFund(address newDevelopmentFund) external onlyGovernor {\n        emit DevelopmentFundUpdated(developmentFund, newDevelopmentFund);\n        developmentFund = newDevelopmentFund;\n    }\n\n    function setOperator(address newOperator) external onlyGovernor {\n        emit OperatorUpdated(operator, newOperator);\n        operator = newOperator;\n    }\n\n    function setLiquidator(address newLiquidator) external onlyGovernor {\n        emit LiquidatorUpdated(liquidator, newLiquidator);\n        liquidator = newLiquidator;\n    }\n\n    function setInterest(uint256 newInterest) external onlyGovernor {\n        emit InterestUpdated(interest, newInterest);\n        interest = newInterest;\n    }\n\n    function setMinimumPrincipalAmount(uint256 newMinimumPrincipalAmount) external onlyGovernor {\n        emit StabilityFeeUpdated(minimumPrincipalAmount, newMinimumPrincipalAmount);\n        minimumPrincipalAmount = newMinimumPrincipalAmount;\n    }\n\n    function setStabilityFee(uint256 newStabilityFee) external onlyGovernor {\n        emit StabilityFeeUpdated(stabilityFee, newStabilityFee);\n        stabilityFee = newStabilityFee;\n    }\n\n    function setPlatformFees(\n        uint256 newStabilizationFee,\n        uint256 newExchangeFee,\n        uint256 newDevelopmentFee\n    ) external onlyGovernor {\n        if (newStabilizationFee + newExchangeFee + newDevelopmentFee != ONE) {\n            revert BaksDAOPlatformFeesDontSumUpToOne(newStabilizationFee, newExchangeFee, newDevelopmentFee);\n        }\n        emit PlatformFeesUpdated(\n            stabilizationFee,\n            newStabilizationFee,\n            exchangeFee,\n            newExchangeFee,\n            developmentFee,\n            newDevelopmentFee\n        );\n        stabilizationFee = newStabilizationFee;\n        exchangeFee = newExchangeFee;\n        developmentFee = newDevelopmentFee;\n    }\n\n    function setMarginCallLoanToValueRatio(uint256 newMarginCallLoanToValueRatio) external onlyGovernor {\n        emit MarginCallLoanToValueRatioUpdated(marginCallLoanToValueRatio, newMarginCallLoanToValueRatio);\n        marginCallLoanToValueRatio = newMarginCallLoanToValueRatio;\n    }\n\n    function setLiquidationLoanToValueRatio(uint256 newLiquidationLoanToValueRatio) external onlyGovernor {\n        emit LiquidationLoanToValueRatioUpdated(liquidationLoanToValueRatio, newLiquidationLoanToValueRatio);\n        liquidationLoanToValueRatio = newLiquidationLoanToValueRatio;\n    }\n\n    function setRebalancingThreshold(uint256 newRebalancingThreshold) external onlyGovernor {\n        emit RebalancingThresholdUpdated(rebalancingThreshold, newRebalancingThreshold);\n        rebalancingThreshold = newRebalancingThreshold;\n    }\n\n    function setMinimumMagisterDepositAmount(uint256 newMinimumMagisterDepositAmount) external onlyGovernor {\n        emit MinimumMagisterDepositAmountUpdated(minimumMagisterDepositAmount, newMinimumMagisterDepositAmount);\n        minimumMagisterDepositAmount = newMinimumMagisterDepositAmount;\n    }\n\n    function setWorkFee(uint256 newWorkFee) external onlyGovernor {\n        emit WorkFeeUpdated(workFee, newWorkFee);\n        workFee = newWorkFee;\n    }\n\n    function setEarlyWithdrawalPeriod(uint256 newEarlyWithdrawalPeriod) external onlyGovernor {\n        emit EarlyWithdrawalPeriodUpdated(earlyWithdrawalPeriod, newEarlyWithdrawalPeriod);\n        earlyWithdrawalPeriod = newEarlyWithdrawalPeriod;\n    }\n\n    function setEarlyWithdrawalFee(uint256 newEarlyWithdrawalFee) external onlyGovernor {\n        emit EarlyWithdrawalFeeUpdated(earlyWithdrawalFee, newEarlyWithdrawalFee);\n        earlyWithdrawalFee = newEarlyWithdrawalFee;\n    }\n\n    function setServicingThreshold(uint256 newServicingThreshold) external onlyGovernor {\n        emit ServicingThresholdUpdated(servicingThreshold, newServicingThreshold);\n        servicingThreshold = newServicingThreshold;\n    }\n\n    function setMinimumLiquidity(uint256 newMinimumLiquidity) external onlyGovernor {\n        emit MinimumLiquidityUpdated(minimumLiquidity, newMinimumLiquidity);\n        minimumLiquidity = newMinimumLiquidity;\n    }\n\n    function setVoiceMintingSchedule(uint256[] memory schedule) external onlyGovernor {\n        _voiceMintingSchedule = new uint256[](schedule.length);\n        for (uint256 i = 0; i < schedule.length; i++) {\n            _voiceMintingSchedule[i] = schedule[i];\n        }\n    }\n\n    function voiceMintingSchedule() external view override returns (uint256[] memory) {\n        return _voiceMintingSchedule;\n    }\n}\n\nabstract contract CoreInside {\n    ICore public core;\n\n    error BaksDAOOnlyDepositaryAllowed();\n\n    modifier onlyDepositary() {\n        if (msg.sender != address(core.depositary())) {\n            revert BaksDAOOnlyDepositaryAllowed();\n        }\n        _;\n    }\n\n    function initializeCoreInside(ICore _core) internal {\n        core = _core;\n    }\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nlibrary Math {\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    function abs(int256 a) internal pure returns (uint256) {\n        return a >= 0 ? uint256(a) : uint256(-a);\n    }\n\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n        uint256 xAux = x;\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n\n        uint256 repeat = 7;\n        while (repeat > 0) {\n            result = (result + x / result) >> 1;\n            repeat--;\n        }\n        uint256 roundedDownResult = x / result;\n\n        return result >= roundedDownResult ? roundedDownResult : result;\n    }\n\n    function fpsqrt(uint256 a) internal pure returns (uint256 result) {\n        if (a == 0) result = 0;\n        else result = sqrt(a) * 1e9;\n    }\n\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n        if (x >= 2**128) {\n            x >>= 128;\n            msb += 128;\n        }\n        if (x >= 2**64) {\n            x >>= 64;\n            msb += 64;\n        }\n        if (x >= 2**32) {\n            x >>= 32;\n            msb += 32;\n        }\n        if (x >= 2**16) {\n            x >>= 16;\n            msb += 16;\n        }\n        if (x >= 2**8) {\n            x >>= 8;\n            msb += 8;\n        }\n        if (x >= 2**4) {\n            x >>= 4;\n            msb += 4;\n        }\n        if (x >= 2**2) {\n            x >>= 2;\n            msb += 2;\n        }\n        if (x >= 2**1) {\n            // No need to shift x any more.\n            msb += 1;\n        }\n    }\n}\n"
    },
    "contracts/libraries/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nerror CallToNonContract(address target);\n\nlibrary Address {\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        if (!isContract(target)) {\n            revert CallToNonContract(target);\n        }\n\n        (bool success, bytes memory returnData) = target.call(data);\n        return verifyCallResult(success, returnData, errorMessage);\n    }\n\n    function delegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        if (!isContract(target)) {\n            revert CallToNonContract(target);\n        }\n\n        (bool success, bytes memory returnData) = target.delegatecall(data);\n        return verifyCallResult(success, returnData, errorMessage);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(account)\n        }\n\n        return codeSize > 0;\n    }\n\n    function verifyCallResult(\n        bool success,\n        bytes memory returnData,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returnData;\n        } else {\n            if (returnData.length > 0) {\n                assembly {\n                    let returnDataSize := mload(returnData)\n                    revert(add(returnData, 32), returnDataSize)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/ExchangeFund.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./libraries/AmountNormalization.sol\";\nimport \"./libraries/EnumerableAddressSet.sol\";\nimport \"./libraries/FixedPointMath.sol\";\nimport \"./libraries/Math.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport {CoreInside, ICore} from \"./Core.sol\";\nimport {Governed} from \"./Governance.sol\";\nimport {IERC20} from \"./interfaces/ERC20.sol\";\nimport {Initializable} from \"./libraries/Upgradability.sol\";\nimport {IPriceOracle} from \"./interfaces/IPriceOracle.sol\";\nimport {IUniswapV2Factory, IUniswapV2Router, IUniswapV2Pair} from \"./interfaces/UniswapV2.sol\";\n\n/// @dev Thrown when trying to list depositable token that has zero decimals.\n/// @param token The address of the token contract.\nerror ExchangeFundDepositableTokenZeroDecimals(IERC20 token);\n\n/// @dev Thrown when trying to list depositable token that has too large decimals.\n/// @param token The address of the token contract.\nerror ExchangeFundDepositableTokenTooLargeDecimals(IERC20 token, uint8 decimals);\n\n/// @dev Thrown when trying to list depositable token that's already listed.\n/// @param token The address of the token contract.\nerror ExchangeFundDepositableTokenAlreadyListed(IERC20 token);\n\n/// @dev Thrown when trying to unlist depositable token that's not listed.\n/// @param token The address of the token contract.\nerror ExchangeFundDepositableTokenNotListed(IERC20 token);\n\n/// @dev Thrown when interacting with a token that's not allowed to be deposited.\n/// @param token The address of the token contract.\nerror ExchangeFundTokenNotAllowedToBeDeposited(IERC20 token);\n\n/// @dev Thrown when interacting with a token that's not allowed to be withdrawn.\n/// @param token The address of the token contract.\nerror ExchangeFundTokenNotAllowedToBeWithdrawn(IERC20 token);\n\n/// @dev Thrown when trying to salvage one of depositable tokens or BAKS.\n/// @param token The address of the token contract.\nerror ExchangeFundTokenNotAllowedToBeSalvaged(IERC20 token);\n\nerror ExchangeFundInsufficientDeposits();\n\nerror ExchangeFundInsufficientLiquidity();\n\nerror ExchangeFundSameTokenSwap(IERC20 token);\n\n/// @dev Thrown when trying to swap token that's not allowed to be swapped.\n/// @param token The address of the token contract.\nerror ExchangeFundTokenNotAllowedToBeSwapped(IERC20 token);\n\n/// @dev Thrown when there's no need to service the `token`/BAKS pair cause the difference between target and\n/// pair price does not exceed servicing threshold.\n/// @param token The address of the token contract.\nerror ExchangeFundNoNeedToService(IERC20 token);\n\ncontract ExchangeFund is CoreInside, Governed, Initializable {\n    using AmountNormalization for IERC20;\n    using EnumerableAddressSet for EnumerableAddressSet.Set;\n    using FixedPointMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant ONE = 100e16;\n    uint8 internal constant DECIMALS = 18;\n\n    uint256 public slippageTolerance;\n    uint256 public swapDeadline;\n\n    mapping(address => mapping(IERC20 => uint256)) public deposits;\n    mapping(address => mapping(IERC20 => uint256)) public liquidity;\n\n    mapping(IERC20 => bool) public depositableTokens;\n    EnumerableAddressSet.Set internal depositableTokensSet;\n\n    event DepositableTokenListed(IERC20 indexed token, IUniswapV2Pair pair);\n    event DepositableTokenUnlisted(IERC20 indexed token);\n\n    event SlippageToleranceUpdated(uint256 slippageTolerance, uint256 newSlippageTolerance);\n    event SwapDeadlineUpdated(uint256 swapDeadline, uint256 newSwapDeadline);\n\n    event Deposit(address indexed account, IERC20 indexed token, uint256 amount);\n    event Swap(address indexed account, IERC20 indexed tokenA, IERC20 indexed tokenB, uint256 amountA, uint256 amountB);\n    event Invest(address indexed account, IERC20 indexed token, uint256 amount);\n    event Divest(address indexed account, IERC20 indexed token, uint256 amount);\n    event Withdrawal(address indexed account, IERC20 indexed token, uint256 amount);\n    event Service(address indexed account, IERC20 indexed token);\n\n    modifier tokenAllowedToBeDeposited(IERC20 token) {\n        if (!depositableTokensSet.contains(address(token))) {\n            revert ExchangeFundTokenNotAllowedToBeDeposited(token);\n        }\n        _;\n    }\n\n    modifier tokenAllowedToBeSwapped(IERC20 token) {\n        if (token != IERC20(core.baks()) && !depositableTokensSet.contains(address(token))) {\n            revert ExchangeFundTokenNotAllowedToBeSwapped(token);\n        }\n        _;\n    }\n\n    function initialize(ICore _core) external initializer {\n        initializeCoreInside(_core);\n        setGovernor(msg.sender);\n\n        slippageTolerance = 5e15; // 0.5 %\n        swapDeadline = 20 minutes;\n\n        IERC20 baks = IERC20(core.baks());\n        IERC20 voice = IERC20(core.voice());\n\n        baks.approve(core.uniswapV2Router(), type(uint256).max);\n        baks.approve(core.depositary(), type(uint256).max);\n\n        voice.approve(core.uniswapV2Router(), type(uint256).max);\n        voice.approve(core.depositary(), type(uint256).max);\n    }\n\n    function deposit(IERC20 token, uint256 amount) external tokenAllowedToBeDeposited(token) {\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        uint256 normalizedAmount = token.normalizeAmount(amount);\n        deposits[msg.sender][token] += normalizedAmount;\n\n        emit Deposit(msg.sender, token, normalizedAmount);\n    }\n\n    function swap(\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint256 amount,\n        bool useWrappedNativeCurrencyAsIntermediateToken\n    ) external tokenAllowedToBeSwapped(tokenA) tokenAllowedToBeSwapped(tokenB) {\n        uint256 normalizedAmount = tokenA.normalizeAmount(amount);\n        if (normalizedAmount > deposits[msg.sender][tokenA]) {\n            revert ExchangeFundInsufficientDeposits();\n        }\n\n        if (tokenA == tokenB) {\n            revert ExchangeFundSameTokenSwap(tokenA);\n        }\n\n        IERC20[] memory path = new IERC20[](useWrappedNativeCurrencyAsIntermediateToken ? 3 : 2);\n        path[0] = tokenA;\n        path[1] = useWrappedNativeCurrencyAsIntermediateToken ? IERC20(core.wrappedNativeCurrency()) : tokenB;\n        if (useWrappedNativeCurrencyAsIntermediateToken) {\n            path[2] = tokenB;\n        }\n\n        IUniswapV2Router uniswapV2Router = IUniswapV2Router(core.uniswapV2Router());\n        uint256[] memory amounts = uniswapV2Router.getAmountsOut(amount, path);\n        uint256 normalizedAmountOut = tokenB.normalizeAmount(amounts[amounts.length - 1]);\n\n        amounts = uniswapV2Router.swapExactTokensForTokens(\n            amount,\n            tokenB.denormalizeAmount(normalizedAmountOut.mul(ONE - slippageTolerance)),\n            path,\n            address(this),\n            block.timestamp + swapDeadline\n        );\n\n        uint256 normalizedTokenAAmount = tokenA.normalizeAmount(amounts[0]);\n        uint256 normalizedTokenBAmount = tokenB.normalizeAmount(amounts[amounts.length - 1]);\n\n        deposits[msg.sender][tokenA] -= normalizedTokenAAmount;\n        deposits[msg.sender][tokenB] += normalizedTokenBAmount;\n\n        emit Swap(msg.sender, tokenA, tokenB, normalizedTokenAAmount, normalizedTokenBAmount);\n    }\n\n    function invest(IERC20 token, uint256 amount) external {\n        uint256 normalizedAmount = token.normalizeAmount(amount);\n        if (normalizedAmount > deposits[msg.sender][token]) {\n            revert ExchangeFundInsufficientDeposits();\n        }\n\n        uint256 tokenValue = quote(token, amount);\n        (, uint256 amountSent, uint256 liquidityMinted) = IUniswapV2Router(core.uniswapV2Router()).addLiquidity(\n            IERC20(core.baks()),\n            token,\n            tokenValue,\n            amount,\n            tokenValue.mul(ONE - slippageTolerance),\n            token.denormalizeAmount(normalizedAmount.mul(ONE - slippageTolerance)),\n            address(this),\n            block.timestamp + swapDeadline\n        );\n\n        deposits[msg.sender][token] -= token.normalizeAmount(amountSent);\n        liquidity[msg.sender][token] += liquidityMinted;\n\n        emit Invest(msg.sender, token, normalizedAmount);\n    }\n\n    function divest(IERC20 token, uint256 amount) external {\n        if (amount > liquidity[msg.sender][token]) {\n            revert ExchangeFundInsufficientLiquidity();\n        }\n\n        (, uint256 amountReceived) = IUniswapV2Router(core.uniswapV2Router()).removeLiquidity(\n            IERC20(core.baks()),\n            token,\n            amount,\n            0,\n            0,\n            address(this),\n            block.timestamp + swapDeadline\n        );\n\n        deposits[msg.sender][token] += token.normalizeAmount(amountReceived);\n        liquidity[msg.sender][token] -= amount;\n\n        emit Divest(msg.sender, token, amount);\n    }\n\n    function withdraw(IERC20 token, uint256 amount) external {\n        if (token == IERC20(core.baks())) {\n            revert ExchangeFundTokenNotAllowedToBeWithdrawn(token);\n        }\n\n        uint256 normalizedAmount = token.normalizeAmount(amount);\n        if (normalizedAmount > deposits[msg.sender][token]) {\n            revert ExchangeFundInsufficientDeposits();\n        }\n\n        deposits[msg.sender][token] -= normalizedAmount;\n        token.safeTransfer(msg.sender, amount);\n\n        emit Withdrawal(msg.sender, token, normalizedAmount);\n    }\n\n    function listDepositableToken(IERC20 token) external onlyGovernor {\n        if (depositableTokensSet.contains(address(token))) {\n            revert ExchangeFundDepositableTokenAlreadyListed(token);\n        }\n\n        uint8 decimals = token.decimals();\n        if (decimals == 0) {\n            revert ExchangeFundDepositableTokenZeroDecimals(token);\n        }\n        if (decimals > DECIMALS) {\n            revert ExchangeFundDepositableTokenTooLargeDecimals(token, decimals);\n        }\n\n        if (depositableTokensSet.add(address(token))) {\n            IERC20 baks = IERC20(core.baks());\n            IUniswapV2Router uniswapV2Router = IUniswapV2Router(core.uniswapV2Router());\n\n            token.approve(address(uniswapV2Router), type(uint256).max);\n\n            IUniswapV2Factory uniswapV2Factory = uniswapV2Router.factory();\n            IUniswapV2Pair uniswapV2Pair = uniswapV2Factory.getPair(baks, token);\n            if (address(uniswapV2Pair) == address(0)) {\n                uniswapV2Pair = uniswapV2Factory.createPair(baks, token);\n            }\n            uniswapV2Pair.approve(address(uniswapV2Router), type(uint256).max);\n\n            depositableTokens[token] = true;\n            emit DepositableTokenListed(token, uniswapV2Pair);\n        }\n    }\n\n    function unlistDepositableToken(IERC20 token) external onlyGovernor {\n        if (!depositableTokensSet.contains(address(token))) {\n            revert ExchangeFundDepositableTokenNotListed(token);\n        }\n\n        if (depositableTokensSet.remove(address(token))) {\n            IUniswapV2Router uniswapV2Router = IUniswapV2Router(core.uniswapV2Router());\n\n            token.approve(address(uniswapV2Router), 0);\n\n            IUniswapV2Factory uniswapV2Factory = uniswapV2Router.factory();\n            IUniswapV2Pair uniswapV2Pair = uniswapV2Factory.getPair(IERC20(core.baks()), token);\n            if (address(uniswapV2Pair) != address(0)) {\n                uniswapV2Pair.approve(address(uniswapV2Router), 0);\n            }\n\n            delete depositableTokens[token];\n            emit DepositableTokenUnlisted(token);\n        }\n    }\n\n    function setSlippageTolerance(uint256 newSlippageTolerance) external onlyGovernor {\n        emit SlippageToleranceUpdated(slippageTolerance, newSlippageTolerance);\n        slippageTolerance = newSlippageTolerance;\n    }\n\n    function setSwapDeadline(uint256 newSwapDeadline) external onlyGovernor {\n        emit SwapDeadlineUpdated(swapDeadline, newSwapDeadline);\n        swapDeadline = newSwapDeadline;\n    }\n\n    function salvage(IERC20 token) external onlyGovernor {\n        address tokenAddress = address(token);\n        if (token == IERC20(core.baks()) || depositableTokensSet.contains(tokenAddress)) {\n            revert ExchangeFundTokenNotAllowedToBeSalvaged(token);\n        }\n        token.safeTransfer(core.operator(), token.balanceOf(address(this)));\n    }\n\n    function service(IERC20 token) external {\n        (uint256 baksReserve, uint256 tokenReserve) = getReserves(token);\n        tokenReserve = token.normalizeAmount(tokenReserve);\n\n        uint256 targetPrice = IPriceOracle(core.priceOracle()).getNormalizedPrice(token);\n        uint256 price = baksReserve.div(tokenReserve);\n        int256 delta = int256(price.div(targetPrice)) - int256(ONE);\n        if (Math.abs(delta) >= core.servicingThreshold()) {\n            int256 amountOut;\n            IERC20[] memory path = new IERC20[](2);\n            if (price > targetPrice) {\n                amountOut = int256(Math.fpsqrt(baksReserve.mul(tokenReserve).mul(targetPrice))) - int256(baksReserve);\n                path[0] = token;\n                path[1] = IERC20(core.baks());\n            } else {\n                amountOut = int256(Math.fpsqrt(baksReserve.mulDiv(tokenReserve, targetPrice))) - int256(tokenReserve);\n                path[0] = IERC20(core.baks());\n                path[1] = token;\n            }\n\n            // NOTE: using this instead of `swapExactTokensForTokens` to shift responsibility for calculating fees to *swap\n            // itself.\n            IUniswapV2Router(core.uniswapV2Router()).swapTokensForExactTokens(\n                Math.abs(amountOut),\n                type(uint256).max,\n                path,\n                address(this),\n                block.timestamp + swapDeadline\n            );\n        }\n\n        topUpLiquidity(token);\n\n        emit Service(msg.sender, token);\n    }\n\n    function getDepositableTokens() external view returns (IERC20[] memory tokens) {\n        uint256 length = depositableTokensSet.elements.length;\n        tokens = new IERC20[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            tokens[i] = IERC20(depositableTokensSet.elements[i]);\n        }\n    }\n\n    function quote(IERC20 token, uint256 amount) public view returns (uint256 baksAmount) {\n        IERC20 baks = IERC20(core.baks());\n        IUniswapV2Router uniswapV2Router = IUniswapV2Router(core.uniswapV2Router());\n\n        IUniswapV2Pair uniswapV2Pair = uniswapV2Router.factory().getPair(baks, token);\n\n        (uint256 reserveA, uint256 reserveB, ) = uniswapV2Pair.getReserves();\n        if (reserveA == 0 || reserveB == 0) {\n            baksAmount = token.normalizeAmount(amount).mul(IPriceOracle(core.priceOracle()).getNormalizedPrice(token));\n            return baksAmount;\n        }\n\n        baksAmount = address(baks) < address(token)\n            ? uniswapV2Router.quote(amount, reserveB, reserveA)\n            : uniswapV2Router.quote(amount, reserveA, reserveB);\n    }\n\n    function topUpLiquidity(IERC20 token) internal {\n        (uint256 baksReserve, uint256 tokenReserve) = getReserves(token);\n        tokenReserve = token.normalizeAmount(tokenReserve);\n\n        uint256 minimumLiquidity = core.minimumLiquidity();\n        if (baksReserve < minimumLiquidity) {\n            uint256 amountADesired = minimumLiquidity - baksReserve;\n            uint256 amountBDesired = token.denormalizeAmount(amountADesired.div(baksReserve.div(tokenReserve)));\n            IUniswapV2Router(core.uniswapV2Router()).addLiquidity(\n                IERC20(core.baks()),\n                token,\n                amountADesired,\n                amountBDesired,\n                amountADesired.mul(ONE - slippageTolerance),\n                token.denormalizeAmount(amountBDesired.mul(ONE - slippageTolerance)),\n                address(this),\n                block.timestamp + swapDeadline\n            );\n        }\n    }\n\n    function getReserves(IERC20 token) internal view returns (uint256 baksReserve, uint256 tokenReserve) {\n        IERC20 baks = IERC20(core.baks());\n        IUniswapV2Pair uniswapV2Pair = IUniswapV2Router(core.uniswapV2Router()).factory().getPair(baks, token);\n\n        (uint256 reserveA, uint256 reserveB, ) = uniswapV2Pair.getReserves();\n        if (address(baks) < address(token)) {\n            baksReserve = reserveA;\n            tokenReserve = reserveB;\n        } else {\n            tokenReserve = reserveA;\n            baksReserve = reserveB;\n        }\n    }\n}\n"
    },
    "contracts/libraries/AmountNormalization.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport {IERC20} from \"./../interfaces/ERC20.sol\";\n\nlibrary AmountNormalization {\n    uint8 internal constant DECIMALS = 18;\n\n    function normalizeAmount(IERC20 self, uint256 denormalizedAmount) internal view returns (uint256 normalizedAmount) {\n        uint256 scale = 10**(DECIMALS - self.decimals());\n        if (scale != 1) {\n            return denormalizedAmount * scale;\n        }\n        return denormalizedAmount;\n    }\n\n    function denormalizeAmount(IERC20 self, uint256 normalizedAmount)\n        internal\n        view\n        returns (uint256 denormalizedAmount)\n    {\n        uint256 scale = 10**(DECIMALS - self.decimals());\n        if (scale != 1) {\n            return normalizedAmount / scale;\n        }\n        return normalizedAmount;\n    }\n}\n"
    },
    "contracts/libraries/EnumerableAddressSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nlibrary EnumerableAddressSet {\n    struct Set {\n        address[] elements;\n        mapping(address => uint256) indexes;\n    }\n\n    function add(Set storage self, address element) internal returns (bool) {\n        if (contains(self, element)) {\n            return false;\n        }\n\n        self.elements.push(element);\n        self.indexes[element] = self.elements.length;\n\n        return true;\n    }\n\n    function remove(Set storage self, address element) internal returns (bool) {\n        uint256 elementIndex = indexOf(self, element);\n        if (elementIndex == 0) {\n            return false;\n        }\n\n        uint256 indexToRemove = elementIndex - 1;\n        uint256 lastIndex = count(self) - 1;\n        if (indexToRemove != lastIndex) {\n            address lastElement = self.elements[lastIndex];\n            self.elements[indexToRemove] = lastElement;\n            self.indexes[lastElement] = elementIndex;\n        }\n        self.elements.pop();\n        delete self.indexes[element];\n\n        return true;\n    }\n\n    function indexOf(Set storage self, address element) internal view returns (uint256) {\n        return self.indexes[element];\n    }\n\n    function contains(Set storage self, address element) internal view returns (bool) {\n        return indexOf(self, element) != 0;\n    }\n\n    function count(Set storage self) internal view returns (uint256) {\n        return self.elements.length;\n    }\n}\n"
    },
    "contracts/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport {IERC20} from \"./../interfaces/ERC20.sol\";\nimport \"./Address.sol\";\n\nerror SafeERC20NoReturnData();\n\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        callWithOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, amount));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        callWithOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, amount));\n    }\n\n    function callWithOptionalReturn(IERC20 token, bytes memory data) internal {\n        address tokenAddress = address(token);\n\n        bytes memory returnData = tokenAddress.functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returnData.length > 0) {\n            if (!abi.decode(returnData, (bool))) {\n                revert SafeERC20NoReturnData();\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/UniswapV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.10;\n\nimport {IERC20} from \"./ERC20.sol\";\n\ninterface IUniswapV2Pair is IERC20 {\n    function token0() external view returns (IERC20);\n\n    function token1() external view returns (IERC20);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n}\n\ninterface IUniswapV2Factory {\n    function createPair(IERC20 tokenA, IERC20 tokenB) external returns (IUniswapV2Pair pair);\n\n    function getPair(IERC20 tokenA, IERC20 tokenB) external view returns (IUniswapV2Pair pair);\n}\n\ninterface IUniswapV2Router {\n    function addLiquidity(\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        IERC20[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        IERC20[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function getAmountsOut(uint256 amountIn, IERC20[] calldata path) external view returns (uint256[] memory amounts);\n\n    function factory() external view returns (IUniswapV2Factory);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n}\n"
    },
    "contracts/ChainlinkPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./interfaces/Chainlink.sol\";\nimport \"./interfaces/IPriceOracle.sol\";\nimport \"./libraries/FixedPointMath.sol\";\nimport {CoreInside, ICore} from \"./Core.sol\";\nimport {Governed} from \"./Governance.sol\";\nimport {IERC20} from \"./interfaces/ERC20.sol\";\nimport {Initializable} from \"./libraries/Upgradability.sol\";\n\ncontract ChainlinkPriceOracle is CoreInside, Governed, Initializable, IPriceOracle {\n    using FixedPointMath for uint256;\n\n    uint256 internal constant ONE = 100e16;\n    uint256 internal constant DIRECT_CONVERSION_PATH_SCALE = 1e10;\n    uint256 internal constant INTERMEDIATE_CONVERSION_PATH_SCALE = 1e8;\n\n    mapping(IERC20 => IChainlinkAggregator) public nativeAggregators;\n    mapping(IERC20 => IChainlinkAggregator) public usdAggregators;\n\n    event AggregatorSet(IERC20 token, IChainlinkAggregator aggregator, bool isQuoteNative);\n\n    function initialize(ICore _core) external initializer {\n        initializeCoreInside(_core);\n        setGovernor(msg.sender);\n    }\n\n    function setAggregator(\n        IERC20 token,\n        IChainlinkAggregator aggregator,\n        bool isQuoteNative\n    ) external onlyGovernor {\n        if (isQuoteNative) {\n            nativeAggregators[token] = aggregator;\n        } else {\n            usdAggregators[token] = aggregator;\n        }\n\n        emit AggregatorSet(token, aggregator, isQuoteNative);\n    }\n\n    function getNormalizedPrice(IERC20 token) external view override returns (uint256 normalizedPrice) {\n        if (token == IERC20(core.baks())) {\n            return ONE;\n        }\n\n        IChainlinkAggregator aggregator = usdAggregators[token];\n        if (address(aggregator) == address(0)) {\n            uint256 tokenToNativeCurrencyPrice = getTokenToNativeCurrencyPrice(token);\n            uint256 nativeCurrencyToUsdPrice = getNativeCurrencyToUsdPrice();\n            return tokenToNativeCurrencyPrice.mulDiv(nativeCurrencyToUsdPrice, INTERMEDIATE_CONVERSION_PATH_SCALE);\n        }\n\n        normalizedPrice = getLatestPrice(token, aggregator) * DIRECT_CONVERSION_PATH_SCALE;\n    }\n\n    function getTokenToNativeCurrencyPrice(IERC20 token) internal view returns (uint256 price) {\n        IChainlinkAggregator aggregator = nativeAggregators[token];\n        if (address(aggregator) == address(0)) {\n            revert PriceOracleTokenUnknown(token);\n        }\n\n        price = getLatestPrice(token, aggregator);\n    }\n\n    function getNativeCurrencyToUsdPrice() internal view returns (uint256 price) {\n        IERC20 wrappedNativeCurrency = IERC20(core.wrappedNativeCurrency());\n        IChainlinkAggregator aggregator = usdAggregators[wrappedNativeCurrency];\n        if (address(aggregator) == address(0)) {\n            revert PriceOracleTokenUnknown(wrappedNativeCurrency);\n        }\n\n        price = getLatestPrice(wrappedNativeCurrency, aggregator);\n    }\n\n    function getLatestPrice(IERC20 token, IChainlinkAggregator aggregator) internal view returns (uint256 price) {\n        (uint80 roundId, int256 answer, , , uint80 answeredInRound) = aggregator.latestRoundData();\n        if (answer <= 0) {\n            revert PriceOracleInvalidPrice(token, answer);\n        }\n\n        price = uint256(answer);\n        if (answeredInRound < roundId) {\n            revert PriceOracleStalePrice(token, price);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/Chainlink.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IChainlinkAggregator {\n    function decimals() external view returns (uint8);\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "contracts/DevelopmentFund.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {Governed} from \"./Governance.sol\";\nimport {Initializable} from \"./libraries/Upgradability.sol\";\nimport {CoreInside, ICore} from \"./Core.sol\";\n\ncontract DevelopmentFund is CoreInside, Initializable, Governed {\n    function initialize(ICore _core) external initializer {\n        initializeCoreInside(_core);\n        setGovernor(msg.sender);\n    }\n}\n"
    },
    "contracts/Depositary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./libraries/AmountNormalization.sol\";\nimport \"./libraries/Deposit.sol\";\nimport \"./libraries/EnumerableAddressSet.sol\";\nimport \"./libraries/FixedPointMath.sol\";\nimport \"./libraries/Magister.sol\";\nimport \"./libraries/Math.sol\";\nimport \"./libraries/Pool.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport {CoreInside, ICore} from \"./Core.sol\";\nimport {Governed} from \"./Governance.sol\";\nimport {IERC20} from \"./interfaces/ERC20.sol\";\nimport {Initializable} from \"./libraries/Upgradability.sol\";\nimport {IPriceOracle} from \"./interfaces/IPriceOracle.sol\";\nimport \"./interfaces/IDepositary.sol\";\nimport \"./interfaces/IBank.sol\";\n\nerror BaksDAOMagisterAlreadyWhitelisted(address magister);\nerror BaksDAOMagisterBlacklisted(address magister);\nerror BaksDAOOnlyDepositorOrMagisterAllowed();\nerror BaksDAOWithdrawAmountExceedsPrincipal();\nerror BaksDAOBelowMinimumMagisterDepositAmount();\nerror BaksDAODepositZeroAmount();\n\ncontract Depositary is CoreInside, Governed, IDepositary, Initializable {\n    using AmountNormalization for IERC20;\n    using Deposit for Deposit.Data;\n    using EnumerableAddressSet for EnumerableAddressSet.Set;\n    using FixedPointMath for uint256;\n    using Magister for Magister.Data;\n    using Pool for Pool.Data;\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant ONE = 100e16;\n\n    mapping(address => Magister.Data) public magisters;\n    EnumerableAddressSet.Set internal magistersSet;\n\n    Pool.Data[] public pools;\n\n    Deposit.Data[] public deposits;\n    mapping(uint256 => mapping(address => uint256)) public currentDepositIds;\n\n    event MagisterWhitelisted(address indexed magister);\n    event MagisterBlacklisted(address indexed magister);\n\n    function initialize(ICore _core) external initializer {\n        initializeCoreInside(_core);\n        setGovernor(msg.sender);\n\n        // Add guard pool and deposit\n        deposits.push(\n            Deposit.Data({\n                id: 0,\n                isActive: false,\n                depositor: address(0),\n                magister: address(0),\n                poolId: 0,\n                principal: 0,\n                depositorTotalAccruedRewards: 0,\n                depositorWithdrawnRewards: 0,\n                magisterTotalAccruedRewards: 0,\n                magisterWithdrawnRewards: 0,\n                createdAt: block.timestamp,\n                lastDepositAt: block.timestamp,\n                lastInteractionAt: block.timestamp,\n                closedAt: block.timestamp\n            })\n        );\n\n        pools.push(\n            Pool.Data({\n                id: 0,\n                depositToken: IERC20(address(0)),\n                priceOracle: IPriceOracle(core.priceOracle()),\n                isCompounding: false,\n                depositsAmount: 0,\n                depositorApr: 0,\n                magisterApr: 0,\n                depositorBonusApr: 0,\n                magisterBonusApr: 0\n            })\n        );\n    }\n\n    function deposit(uint256 poolId, uint256 amount) external {\n        deposit(poolId, amount, address(this));\n    }\n\n    function withdraw(uint256 depositId, uint256 amount) external {\n        Deposit.Data storage d = deposits[depositId];\n        Pool.Data storage p = pools[d.poolId];\n\n        if (!(msg.sender == d.depositor || msg.sender == d.magister)) {\n            revert BaksDAOOnlyDepositorOrMagisterAllowed();\n        }\n\n        uint256 normalizedAmount = p.depositToken.normalizeAmount(amount);\n        accrueRewards(d.id);\n\n        uint256 magisterAmount = Math.min(d.magisterTotalAccruedRewards - d.magisterWithdrawnRewards, normalizedAmount);\n        (\n            uint256 depositorReward,\n            uint256 depositorBonusReward,\n            uint256 magisterReward,\n            uint256 magisterBonusReward\n        ) = splitRewards(d.poolId, d.depositorTotalAccruedRewards - d.depositorWithdrawnRewards, magisterAmount);\n\n        if (msg.sender == d.magister) {\n            IERC20(core.baks()).safeTransferFrom(core.exchangeFund(), d.magister, magisterReward);\n            if (magisterBonusReward > 0) {\n                IERC20(core.voice()).safeTransferFrom(core.exchangeFund(), d.magister, magisterBonusReward);\n            }\n\n            d.magisterWithdrawnRewards += magisterAmount;\n        } else {\n            if (normalizedAmount > d.principal) {\n                revert BaksDAOWithdrawAmountExceedsPrincipal();\n            }\n\n            uint256 fee;\n            if (p.isCompounding) {\n                fee = core.workFee();\n\n                if (block.timestamp < d.lastDepositAt + core.earlyWithdrawalPeriod()) {\n                    fee += core.earlyWithdrawalFee();\n                }\n\n                depositorReward = depositorReward.mul(ONE - fee);\n            }\n\n            if (p.depositToken != IERC20(core.baks()) && p.depositToken != IERC20(core.voice())) {\n                p.depositToken.safeTransfer(d.depositor, normalizedAmount);\n            }\n            IERC20(core.baks()).safeTransferFrom(\n                core.exchangeFund(),\n                d.depositor,\n                p.depositToken == IERC20(core.baks()) ? normalizedAmount + depositorReward : depositorReward\n            );\n            if (depositorBonusReward > 0) {\n                IERC20(core.voice()).safeTransferFrom(core.exchangeFund(), d.depositor, depositorBonusReward);\n            }\n\n            p.depositsAmount -= normalizedAmount;\n            d.principal -= normalizedAmount;\n            d.depositorWithdrawnRewards += d.depositorTotalAccruedRewards - d.depositorWithdrawnRewards;\n        }\n\n        d.lastInteractionAt = block.timestamp;\n        if (d.principal == 0) {\n            d.isActive = false;\n            d.closedAt = block.timestamp;\n            delete currentDepositIds[d.poolId][msg.sender];\n        }\n    }\n\n    function whitelistMagister(address magister) external onlyGovernor {\n        if (magistersSet.contains(magister)) {\n            revert BaksDAOMagisterAlreadyWhitelisted(magister);\n        }\n\n        if (magistersSet.add(magister)) {\n            Magister.Data storage m = magisters[magister];\n            m.addr = magister;\n            if (m.createdAt == 0) {\n                m.createdAt = block.timestamp;\n            }\n            m.isActive = true;\n\n            emit MagisterWhitelisted(magister);\n        }\n    }\n\n    function blacklistMagister(address magister) external onlyGovernor {\n        if (!magistersSet.contains(magister)) {\n            revert BaksDAOMagisterBlacklisted(magister);\n        }\n\n        if (magistersSet.remove(magister)) {\n            magisters[magister].isActive = false;\n            emit MagisterBlacklisted(magister);\n        }\n    }\n\n    function addPool(\n        IERC20 depositToken,\n        bool isCompounding,\n        uint256 depositorApr,\n        uint256 magisterApr,\n        uint256 depositorBonusApr,\n        uint256 magisterBonusApr\n    ) external onlyGovernor {\n        uint256 poolId = pools.length;\n        pools.push(\n            Pool.Data({\n                id: poolId,\n                depositToken: depositToken,\n                priceOracle: IPriceOracle(core.priceOracle()),\n                isCompounding: isCompounding,\n                depositsAmount: 0,\n                depositorApr: depositorApr,\n                magisterApr: magisterApr,\n                depositorBonusApr: depositorBonusApr,\n                magisterBonusApr: magisterBonusApr\n            })\n        );\n    }\n\n    function updatePool(\n        uint256 poolId,\n        bool isCompounding,\n        uint256 depositorApr,\n        uint256 magisterApr,\n        uint256 depositorBonusApr,\n        uint256 magisterBonusApr\n    ) external onlyGovernor {\n        Pool.Data storage pool = pools[poolId];\n        pool.isCompounding = isCompounding;\n        pool.depositorApr = depositorApr;\n        pool.magisterApr = magisterApr;\n        pool.depositorBonusApr = depositorBonusApr;\n        pool.magisterBonusApr = magisterBonusApr;\n    }\n\n    function getActiveMagisterAddresses() external view returns (address[] memory activeMagisterAddresses) {\n        activeMagisterAddresses = magistersSet.elements;\n    }\n\n    function getActiveMagisters() external view returns (Magister.Data[] memory activeMagisters) {\n        uint256 length = magistersSet.elements.length;\n        activeMagisters = new Magister.Data[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            activeMagisters[i] = magisters[magistersSet.elements[i]];\n        }\n    }\n\n    function getPoolsCount() external view returns (uint256) {\n        return pools.length;\n    }\n\n    function getPools() external view returns (Pool.Data[] memory) {\n        return pools;\n    }\n\n    function getMagisterDepositIds(address magister) external view returns (uint256[] memory) {\n        return magisters[magister].depositIds;\n    }\n\n    function getTotalValueLocked() external view returns (uint256 totalValueLocked) {\n        for (uint256 i = 0; i < pools.length; i++) {\n            totalValueLocked += pools[i].getDepositsValue();\n        }\n    }\n\n    function deposit(\n        uint256 poolId,\n        uint256 amount,\n        address magister\n    ) public {\n        if (magister == msg.sender || !(magister == address(this) || magisters[magister].isActive)) {\n            revert BaksDAOMagisterBlacklisted(magister);\n        }\n\n        IERC20 baks = IERC20(core.baks());\n        IERC20 voice = IERC20(core.voice());\n\n        Pool.Data storage p = pools[poolId];\n        p.depositToken.safeTransferFrom(\n            msg.sender,\n            (p.depositToken == baks || p.depositToken == voice) ? core.exchangeFund() : address(this),\n            amount\n        );\n\n        uint256 normalizedAmount = p.depositToken.normalizeAmount(amount);\n        p.depositsAmount += normalizedAmount;\n\n        if (currentDepositIds[poolId][msg.sender] == 0) {\n            if (amount == 0) {\n                revert BaksDAODepositZeroAmount();\n            }\n\n            uint256 id = deposits.length;\n            deposits.push(\n                Deposit.Data({\n                    id: id,\n                    isActive: true,\n                    magister: magister,\n                    depositor: msg.sender,\n                    poolId: poolId,\n                    principal: normalizedAmount,\n                    depositorTotalAccruedRewards: 0,\n                    depositorWithdrawnRewards: 0,\n                    magisterTotalAccruedRewards: 0,\n                    magisterWithdrawnRewards: 0,\n                    createdAt: block.timestamp,\n                    lastDepositAt: block.timestamp,\n                    lastInteractionAt: block.timestamp,\n                    closedAt: 0\n                })\n            );\n\n            currentDepositIds[poolId][msg.sender] = id;\n            if (magister != address(this)) {\n                uint256 depositTokenPrice = IPriceOracle(core.priceOracle()).getNormalizedPrice(p.depositToken);\n                if (normalizedAmount.mul(depositTokenPrice) < core.minimumMagisterDepositAmount()) {\n                    revert BaksDAOBelowMinimumMagisterDepositAmount();\n                }\n\n                magisters[magister].depositIds.push(id);\n            }\n            if (p.depositToken != baks) {\n                IBank(core.bank()).onNewDeposit(p.depositToken, normalizedAmount);\n            }\n        } else {\n            Deposit.Data storage d = deposits[currentDepositIds[poolId][msg.sender]];\n            accrueRewards(d.id);\n\n            uint256 r = d.depositorTotalAccruedRewards - d.depositorWithdrawnRewards;\n            (uint256 depositorRewards, uint256 depositorBonusRewards, , ) = splitRewards(d.poolId, r, 0);\n            baks.safeTransferFrom(core.exchangeFund(), d.depositor, depositorRewards);\n            if (depositorBonusRewards > 0) {\n                voice.safeTransferFrom(core.exchangeFund(), d.depositor, depositorBonusRewards);\n            }\n\n            d.principal += normalizedAmount;\n            d.depositorWithdrawnRewards += r;\n            d.lastDepositAt = block.timestamp;\n            d.lastInteractionAt = block.timestamp;\n        }\n    }\n\n    function getRewards(uint256 depositId) public view returns (uint256 depositorRewards, uint256 magisterRewards) {\n        Deposit.Data memory d = deposits[depositId];\n\n        (uint256 dr, uint256 mr) = calculateRewards(depositId);\n        depositorRewards = dr + d.depositorTotalAccruedRewards - d.depositorWithdrawnRewards;\n        magisterRewards = mr + d.magisterTotalAccruedRewards - d.magisterWithdrawnRewards;\n    }\n\n    function accrueRewards(uint256 depositId) internal {\n        (uint256 depositorRewards, uint256 magisterRewards) = calculateRewards(depositId);\n\n        Deposit.Data storage d = deposits[depositId];\n        IERC20 depositToken = pools[d.poolId].depositToken;\n        uint256 depositTokenPrice = depositToken == IERC20(core.baks())\n            ? ONE\n            : IPriceOracle(core.priceOracle()).getNormalizedPrice(depositToken);\n        if (d.magister != address(this) && magisters[d.magister].isActive) {\n            d.magisterTotalAccruedRewards += magisterRewards;\n            magisters[d.magister].totalIncome += magisterRewards.mul(depositTokenPrice);\n        }\n\n        d.depositorTotalAccruedRewards += depositorRewards;\n        if (magisters[msg.sender].isActive) {\n            magisters[d.magister].totalIncome += depositorRewards.mul(depositTokenPrice);\n        }\n    }\n\n    function calculateRewards(uint256 depositId)\n        internal\n        view\n        returns (uint256 depositorRewards, uint256 magisterRewards)\n    {\n        Deposit.Data memory d = deposits[depositId];\n        Pool.Data memory p = pools[d.poolId];\n\n        uint256 totalRewards = d.principal.mul(\n            p.calculateMultiplier(core.workFee(), block.timestamp - d.lastInteractionAt)\n        );\n        uint256 totalApr = p.getTotalApr();\n\n        depositorRewards = totalRewards.mulDiv(p.getDepositorApr(), totalApr);\n        magisterRewards = totalRewards.mulDiv(p.getMagisterApr(), totalApr);\n    }\n\n    function splitRewards(\n        uint256 poolId,\n        uint256 _depositorRewards,\n        uint256 _magisterRewards\n    )\n        internal\n        view\n        returns (\n            uint256 depositorRewards,\n            uint256 depositorBonusRewards,\n            uint256 magisterRewards,\n            uint256 magisterBonusRewards\n        )\n    {\n        IPriceOracle priceOracle = IPriceOracle(core.priceOracle());\n\n        Pool.Data memory p = pools[poolId];\n\n        uint256 depositorTotalApr = p.getDepositorApr();\n        uint256 magisterTotalApr = p.getMagisterApr();\n        uint256 depositTokenPrice = p.depositToken == IERC20(core.baks())\n            ? ONE\n            : priceOracle.getNormalizedPrice(p.depositToken);\n\n        depositorRewards = _depositorRewards.mul(depositTokenPrice);\n        magisterRewards = _magisterRewards.mul(depositTokenPrice);\n\n        try priceOracle.getNormalizedPrice(IERC20(core.voice())) returns (uint256 bonusTokenPrice) {\n            if (bonusTokenPrice > 0) {\n                depositorBonusRewards = depositorRewards.mulDiv(\n                    p.depositorBonusApr.mul(bonusTokenPrice),\n                    depositorTotalApr\n                );\n                magisterBonusRewards = magisterRewards.mulDiv(\n                    p.magisterBonusApr.mul(bonusTokenPrice),\n                    magisterTotalApr\n                );\n\n                depositorRewards = depositorRewards.mulDiv(p.depositorApr, depositorTotalApr);\n                magisterRewards = magisterRewards.mulDiv(p.magisterApr, magisterTotalApr);\n            }\n        } catch {}\n    }\n}\n"
    },
    "contracts/libraries/Deposit.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./FixedPointMath.sol\";\nimport {IERC20} from \"./../interfaces/ERC20.sol\";\nimport {IPriceOracle} from \"./../interfaces/IPriceOracle.sol\";\n\nlibrary Deposit {\n    using FixedPointMath for uint256;\n\n    struct Data {\n        uint256 id;\n        bool isActive;\n        address depositor;\n        address magister;\n        uint256 poolId;\n        uint256 principal;\n        uint256 depositorTotalAccruedRewards;\n        uint256 depositorWithdrawnRewards;\n        uint256 magisterTotalAccruedRewards;\n        uint256 magisterWithdrawnRewards;\n        uint256 createdAt;\n        uint256 lastDepositAt;\n        uint256 lastInteractionAt;\n        uint256 closedAt;\n    }\n}\n"
    },
    "contracts/libraries/Magister.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./FixedPointMath.sol\";\nimport {IERC20} from \"./../interfaces/ERC20.sol\";\nimport {IPriceOracle} from \"./../interfaces/IPriceOracle.sol\";\n\nlibrary Magister {\n    using FixedPointMath for uint256;\n\n    struct Data {\n        bool isActive;\n        uint256 createdAt;\n        address addr;\n        uint256 totalIncome;\n        uint256[] depositIds;\n    }\n}\n"
    },
    "contracts/libraries/Pool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./Deposit.sol\";\nimport \"./FixedPointMath.sol\";\nimport {IERC20} from \"./../interfaces/ERC20.sol\";\nimport {IPriceOracle} from \"./../interfaces/IPriceOracle.sol\";\n\nlibrary Pool {\n    using FixedPointMath for uint256;\n\n    struct Data {\n        uint256 id;\n        IERC20 depositToken;\n        IPriceOracle priceOracle;\n        bool isCompounding;\n        uint256 depositsAmount;\n        uint256 depositorApr;\n        uint256 magisterApr;\n        uint256 depositorBonusApr;\n        uint256 magisterBonusApr;\n    }\n\n    uint256 internal constant ONE = 100e16;\n    uint256 internal constant SECONDS_PER_YEAR = 31557600;\n\n    function getDepositsValue(Data memory self) internal view returns (uint256 depositsValue) {\n        if (self.depositsAmount == 0) {\n            return 0;\n        }\n\n        uint256 depositTokenPrice = self.priceOracle.getNormalizedPrice(self.depositToken);\n        depositsValue = self.depositsAmount.mul(depositTokenPrice);\n    }\n\n    function calculateMultiplier(\n        Data memory self,\n        uint256 fee,\n        uint256 timeDelta\n    ) internal pure returns (uint256 multiplier) {\n        uint256 totalApr = getTotalApr(self);\n        if (!self.isCompounding) {\n            multiplier = totalApr.mul(timeDelta.mulDiv(ONE, SECONDS_PER_YEAR));\n        } else {\n            multiplier =\n                FixedPointMath.pow(ONE + (ONE - fee).mul(totalApr).div(SECONDS_PER_YEAR * ONE), timeDelta * ONE) -\n                ONE;\n        }\n    }\n\n    function getDepositorApr(Data memory self) internal pure returns (uint256 depositorApr) {\n        depositorApr = self.depositorApr + self.depositorBonusApr;\n    }\n\n    function getMagisterApr(Data memory self) internal pure returns (uint256 magisterApr) {\n        magisterApr = self.magisterApr + self.magisterBonusApr;\n    }\n\n    function getTotalApr(Data memory self) internal pure returns (uint256 totalApr) {\n        totalApr = getDepositorApr(self) + getMagisterApr(self);\n    }\n}\n"
    },
    "contracts/interfaces/IDepositary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\ninterface IDepositary {\n    function getTotalValueLocked() external view returns (uint256 totalValueLocked);\n}\n"
    },
    "contracts/interfaces/IBank.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport {IERC20} from \"./ERC20.sol\";\n\ninterface IBank {\n    function onNewDeposit(IERC20 token, uint256 amount) external;\n}\n"
    },
    "contracts/Bank.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./interfaces/IBank.sol\";\nimport \"./interfaces/IWrappedNativeCurrency.sol\";\nimport \"./libraries/AmountNormalization.sol\";\nimport \"./libraries/CollateralToken.sol\";\nimport \"./libraries/EnumerableAddressSet.sol\";\nimport \"./libraries/FixedPointMath.sol\";\nimport \"./libraries/Loan.sol\";\nimport \"./libraries/Math.sol\";\nimport \"./libraries/MintingStage.sol\";\nimport \"./libraries/ReentrancyGuard.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport {CoreInside, ICore} from \"./Core.sol\";\nimport {Governed} from \"./Governance.sol\";\nimport {IDepositary} from \"./Depositary.sol\";\nimport {IERC20, IMintableAndBurnableERC20} from \"./interfaces/ERC20.sol\";\nimport {Initializable} from \"./libraries/Upgradability.sol\";\n\n/// @dev Thrown when trying to list collateral token that has zero decimals.\n/// @param token The address of the collateral token contract.\nerror BaksDAOCollateralTokenZeroDecimals(IERC20 token);\n\n/// @dev Thrown when trying to list collateral token that has too large decimals.\n/// @param token The address of the collateral token contract.\nerror BaksDAOCollateralTokenTooLargeDecimals(IERC20 token, uint8 decimals);\n\n/// @dev Thrown when trying to list collateral token that's already listed.\n/// @param token The address of the collateral token contract.\nerror BaksDAOCollateralTokenAlreadyListed(IERC20 token);\n\n/// @dev Thrown when trying to unlist collateral token that's not listed.\n/// @param token The address of the collateral token contract.\nerror BaksDAOCollateralTokenNotListed(IERC20 token);\n\n/// @dev Thrown when interacting with a token that's not allowed as collateral.\n/// @param token The address of the collateral token contract.\nerror BaksDAOTokenNotAllowedAsCollateral(IERC20 token);\n\n/// @dev Thrown when trying to set initial loan-to-value ratio that higher than margin call or liquidation ones.\n/// @param token The address of the collateral token contract.\n/// @param initialLoanToValueRatio The initial loan-to-value ratio that was tried to set.\nerror BaksDAOInitialLoanToValueRatioTooHigh(IERC20 token, uint256 initialLoanToValueRatio);\n\n/// @dev Thrown when trying to interact with inactive loan with `id` id.\n/// @param id The loan id.\nerror BaksDAOInactiveLoan(uint256 id);\n\n/// @dev Thrown when trying to liquidate healthy loan with `id` id.\n/// @param id The loan id.\nerror BaksDAOLoanNotSubjectToLiquidation(uint256 id);\n\n/// @dev Thrown when trying to interact with loan with `id` id that is subject to liquidation.\n/// @param id The loan id.\nerror BaksDAOLoanIsSubjectToLiquidation(uint256 id);\n\n/// @dev Thrown when borrowing a zero amount of stablecoin.\nerror BaksDAOBorrowZeroAmount();\n\n/// @dev Thrown when trying to borrow below minimum principal amount.\nerror BaksDAOBorrowBelowMinimumPrincipalAmount();\n\n/// @dev Thrown when depositing a zero amount of collateral token.\nerror BaksDAODepositZeroAmount();\n\n/// @dev Thrown when repaying a zero amount of stablecoin.\nerror BaksDAORepayZeroAmount();\n\n/// @dev Thrown when there's no need to rebalance the platform.\nerror BaksDAONoNeedToRebalance();\n\n/// @dev Thrown when trying to rebalance the platform and there is a shortage of funds to burn.\n/// @param shortage Shoratge of funds to burn.\nerror BaksDAOStabilizationFundOutOfFunds(uint256 shortage);\n\n/// @dev Thrown when trying to salvage one of allowed collateral tokens or stablecoin.\n/// @param token The address of the token contract.\nerror BaksDAOTokenNotAllowedToBeSalvaged(IERC20 token);\n\n/// @dev Thrown when trying to deposit native currency collateral to the non-wrapped native currency token loan\n/// with `id` id.\n/// @param id The loan id.\nerror BaksDAONativeCurrencyCollateralNotAllowed(uint256 id);\n\nerror BaksDAONativeCurrencyTransferFailed();\n\nerror BaksDAOPlainNativeCurrencyTransferNotAllowed();\n\nerror BaksDAOInsufficientSecurityAmount(uint256 minimumRequiredSecurityAmount);\n\nerror BaksDAOVoiceNothingToMint();\n\nerror BaksDAOVoiceMintingEnded();\n\n/// @title Core smart contract of BaksDAO platform\n/// @author BaksDAO\n/// @notice You should use this contract to interact with the BaksDAO platform.\n/// @notice Only this contract can issue BAKS and BDV tokens.\ncontract Bank is CoreInside, Governed, IBank, Initializable, ReentrancyGuard {\n    using AmountNormalization for IERC20;\n    using AmountNormalization for IWrappedNativeCurrency;\n    using CollateralToken for CollateralToken.Data;\n    using EnumerableAddressSet for EnumerableAddressSet.Set;\n    using FixedPointMath for uint256;\n    using Loan for Loan.Data;\n    using MintingStage for uint256;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IMintableAndBurnableERC20;\n    using SafeERC20 for IWrappedNativeCurrency;\n\n    enum Health {\n        Ok,\n        MarginCall,\n        Liquidation\n    }\n\n    uint256 internal constant ONE = 100e16;\n    uint8 internal constant DECIMALS = 18;\n\n    Loan.Data[] public loans;\n    mapping(address => uint256[]) public loanIds;\n\n    mapping(IERC20 => CollateralToken.Data) public collateralTokens;\n    EnumerableAddressSet.Set internal collateralTokensSet;\n\n    uint256 public nextVoiceMintingStage;\n\n    event CollateralTokenListed(IERC20 indexed token);\n    event CollateralTokenUnlisted(IERC20 indexed token);\n\n    event InitialLoanToValueRatioUpdated(\n        IERC20 indexed token,\n        uint256 initialLoanToValueRatio,\n        uint256 newInitialLoanToValueRatio\n    );\n\n    event Borrow(\n        uint256 indexed id,\n        address indexed borrower,\n        IERC20 indexed token,\n        uint256 principalAmount,\n        uint256 collateralAmount,\n        uint256 initialLoanToValueRatio\n    );\n    event Deposit(uint256 indexed id, uint256 collateralAmount);\n    event Repay(uint256 indexed id, uint256 principalAmount);\n    event Repaid(uint256 indexed id);\n\n    event Liquidated(uint256 indexed id);\n\n    event Rebalance(int256 delta, uint256 voiceMinted);\n\n    modifier tokenAllowedAsCollateral(IERC20 token) {\n        if (!collateralTokensSet.contains(address(token))) {\n            revert BaksDAOTokenNotAllowedAsCollateral(token);\n        }\n        _;\n    }\n\n    modifier onActiveLoan(uint256 id) {\n        if (id >= loans.length || !loans[id].isActive) {\n            revert BaksDAOInactiveLoan(id);\n        }\n        _;\n    }\n\n    modifier notOnSubjectToLiquidation(uint256 loanId) {\n        if (checkHealth(loanId) == Health.Liquidation) {\n            revert BaksDAOLoanIsSubjectToLiquidation(loanId);\n        }\n        _;\n    }\n\n    modifier onSubjectToLiquidation(uint256 loanId) {\n        if (checkHealth(loanId) != Health.Liquidation) {\n            revert BaksDAOLoanNotSubjectToLiquidation(loanId);\n        }\n        _;\n    }\n\n    receive() external payable {\n        if (msg.sender != core.wrappedNativeCurrency()) {\n            revert BaksDAOPlainNativeCurrencyTransferNotAllowed();\n        }\n    }\n\n    function initialize(ICore _core) external initializer {\n        initializeReentrancyGuard();\n        initializeCoreInside(_core);\n        setGovernor(msg.sender);\n    }\n\n    /// @notice Increases loan's principal on `collateralToken` collateral token and mints `amount` of stablecoin.\n    /// @dev The caller must have allowed this contract to spend a sufficient amount of collateral tokens to cover\n    /// initial loan-to-value ratio.\n    /// @param collateralToken The address of the collateral token contract.\n    /// @param amount The amount of stablecoin to borrow and issue.\n    function borrow(IERC20 collateralToken, uint256 amount)\n        external\n        tokenAllowedAsCollateral(collateralToken)\n        returns (Loan.Data memory)\n    {\n        (\n            Loan.Data memory loan,\n            uint256 exchangeFee,\n            uint256 developmentFee,\n            uint256 stabilityFee\n        ) = calculateLoanByPrincipalAmount(collateralToken, amount);\n\n        collateralToken.safeTransferFrom(msg.sender, core.operator(), collateralToken.denormalizeAmount(stabilityFee));\n        collateralToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            collateralToken.denormalizeAmount(loan.collateralAmount)\n        );\n\n        return _createLoan(loan, exchangeFee, developmentFee);\n    }\n\n    /// @notice Increases loan's principal on wrapped native currency token and mints stablecoin.\n    function borrowInNativeCurrency(uint256 amount) external payable nonReentrant returns (Loan.Data memory) {\n        IWrappedNativeCurrency wrappedNativeCurrency = IWrappedNativeCurrency(core.wrappedNativeCurrency());\n\n        (\n            Loan.Data memory loan,\n            uint256 exchangeFee,\n            uint256 developmentFee,\n            uint256 stabilityFee\n        ) = calculateLoanByPrincipalAmount(wrappedNativeCurrency, amount);\n        loan.isNativeCurrency = true;\n\n        uint256 securityAmount = loan.collateralAmount + stabilityFee;\n        if (msg.value < securityAmount) {\n            revert BaksDAOInsufficientSecurityAmount(securityAmount);\n        }\n\n        wrappedNativeCurrency.deposit{value: securityAmount}();\n        wrappedNativeCurrency.safeTransfer(core.operator(), wrappedNativeCurrency.denormalizeAmount(stabilityFee));\n\n        uint256 change;\n        unchecked {\n            change = msg.value - securityAmount;\n        }\n        if (change > 0) {\n            (bool success, ) = msg.sender.call{value: change}(\"\");\n            if (!success) {\n                revert BaksDAONativeCurrencyTransferFailed();\n            }\n        }\n\n        return _createLoan(loan, exchangeFee, developmentFee);\n    }\n\n    /// @notice Deposits `amount` of collateral token to loan with `id` id.\n    /// @dev The caller must have allowed this contract to spend `amount` of collateral tokens.\n    /// @param loanId The loan id.\n    /// @param amount The amount of collateral token to deposit.\n    function deposit(uint256 loanId, uint256 amount) external onActiveLoan(loanId) notOnSubjectToLiquidation(loanId) {\n        loans[loanId].collateralToken.safeTransferFrom(msg.sender, address(this), amount);\n        _deposit(loanId, amount);\n    }\n\n    /// @notice Deposits wrapped native currency token to loan with `id` id.\n    function depositInNativeCurrency(uint256 loanId)\n        external\n        payable\n        nonReentrant\n        onActiveLoan(loanId)\n        notOnSubjectToLiquidation(loanId)\n    {\n        IWrappedNativeCurrency wrappedNativeCurrency = IWrappedNativeCurrency(core.wrappedNativeCurrency());\n        if (loans[loanId].collateralToken != wrappedNativeCurrency) {\n            revert BaksDAONativeCurrencyCollateralNotAllowed(loanId);\n        }\n        wrappedNativeCurrency.deposit{value: msg.value}();\n        _deposit(loanId, msg.value);\n    }\n\n    /// @notice Decreases principal of loan with `id` id by `amount` of stablecoin.\n    /// @param loanId The loan id.\n    /// @param amount The amount of stablecoin to repay.\n    function repay(uint256 loanId, uint256 amount)\n        external\n        nonReentrant\n        onActiveLoan(loanId)\n        notOnSubjectToLiquidation(loanId)\n    {\n        if (amount == 0) {\n            revert BaksDAORepayZeroAmount();\n        }\n        Loan.Data storage loan = loans[loanId];\n        loan.accrueInterest();\n\n        amount = Math.min(loan.principalAmount + loan.interestAmount, amount);\n        uint256 interestPayment;\n        uint256 principalPayment;\n        if (loan.interestAmount < amount) {\n            principalPayment = amount - loan.interestAmount;\n            interestPayment = loan.interestAmount;\n\n            loan.principalAmount -= principalPayment;\n            loan.interestAmount = 0;\n        } else {\n            interestPayment = amount;\n            loan.interestAmount -= interestPayment;\n        }\n\n        IMintableAndBurnableERC20 baks = IMintableAndBurnableERC20(core.baks());\n\n        if (interestPayment > 0) {\n            baks.safeTransferFrom(msg.sender, core.developmentFund(), interestPayment);\n        }\n\n        if (principalPayment > 0) {\n            baks.safeTransferFrom(msg.sender, address(this), principalPayment);\n        }\n\n        loan.lastInteractionAt = block.timestamp;\n        if (loan.principalAmount > 0) {\n            emit Repay(loanId, amount);\n        } else {\n            uint256 denormalizedCollateralAmount = loan.collateralToken.denormalizeAmount(loan.collateralAmount);\n            collateralTokens[loan.collateralToken].collateralAmount -= loan.collateralAmount;\n\n            loan.collateralAmount = 0;\n\n            baks.burn(address(this), amount + loan.stabilizationFee);\n\n            loan.isActive = false;\n            emit Repaid(loanId);\n\n            loan.collateralToken.safeTransfer(loan.borrower, denormalizedCollateralAmount);\n\n            /* if (!loan.isNativeCurrency) {\n                loan.collateralToken.safeTransfer(loan.borrower, denormalizedCollateralAmount);\n            } else {\n                IWrappedNativeCurrency(core.wrappedNativeCurrency()).withdraw(denormalizedCollateralAmount);\n                (bool success, ) = msg.sender.call{value: denormalizedCollateralAmount}(\"\");\n                if (!success) {\n                    revert BaksDAONativeCurrencyTransferFailed();\n                }\n            } */\n        }\n    }\n\n    function liquidate(uint256 loanId) external onActiveLoan(loanId) onSubjectToLiquidation(loanId) {\n        Loan.Data storage loan = loans[loanId];\n\n        collateralTokens[loan.collateralToken].collateralAmount -= loan.collateralAmount;\n        loan.collateralToken.safeTransfer(\n            core.developmentFund(),\n            loan.collateralToken.denormalizeAmount(loan.collateralAmount)\n        );\n\n        IMintableAndBurnableERC20 baks = IMintableAndBurnableERC20(core.baks());\n        uint256 collateralValue = loan.getCollateralValue();\n        baks.burn(core.liquidator(), loan.principalAmount);\n        baks.burn(address(this), collateralValue - loan.principalAmount);\n\n        loan.isActive = false;\n        emit Liquidated(loanId);\n    }\n\n    function rebalance() external {\n        IMintableAndBurnableERC20 baks = IMintableAndBurnableERC20(core.baks());\n\n        uint256 totalValueLocked = getTotalValueLocked();\n        uint256 totalSupply = baks.totalSupply();\n\n        int256 delta = int256(totalSupply) - int256(totalValueLocked);\n        uint256 absoluteDelta = Math.abs(delta);\n        uint256 p = absoluteDelta.div(totalSupply);\n        if (p < core.rebalancingThreshold()) {\n            revert BaksDAONoNeedToRebalance();\n        }\n\n        if (delta > 0) {\n            try baks.burn(address(this), absoluteDelta) {} catch {\n                uint256 balance = baks.balanceOf(address(this));\n                revert BaksDAOStabilizationFundOutOfFunds(absoluteDelta - balance);\n            }\n        } else {\n            baks.mint(address(this), absoluteDelta);\n        }\n\n        emit Rebalance(delta, 0);\n    }\n\n    function mintVoice() external {\n        uint256[] memory voiceMintingSchedule = core.voiceMintingSchedule();\n        uint256 length = voiceMintingSchedule.length;\n\n        if (nextVoiceMintingStage >= length) {\n            revert BaksDAOVoiceMintingEnded();\n        }\n\n        uint256 totalValueLocked = getTotalValueLocked();\n        uint256 voiceToMint;\n\n        for (uint256 i = nextVoiceMintingStage; i < length; i++) {\n            (uint256 targetTotalValueLocked, uint256 amount) = voiceMintingSchedule[i].split();\n\n            if (totalValueLocked < targetTotalValueLocked) {\n                nextVoiceMintingStage = i;\n                break;\n            }\n\n            voiceToMint += amount;\n        }\n\n        if (voiceToMint == 0) {\n            revert BaksDAOVoiceNothingToMint();\n        }\n\n        IMintableAndBurnableERC20 voice = IMintableAndBurnableERC20(core.voice());\n        voice.mint(msg.sender, voiceToMint);\n\n        emit Rebalance(0, voiceToMint);\n    }\n\n    function onNewDeposit(IERC20 token, uint256 amount) external onlyDepositary {\n        IMintableAndBurnableERC20 baks = IMintableAndBurnableERC20(core.baks());\n        if (token == baks) {\n            return;\n        }\n\n        amount = amount.mul(IPriceOracle(core.priceOracle()).getNormalizedPrice(token));\n\n        baks.mint(address(this), amount.mul(core.stabilizationFee()));\n        baks.mint(core.exchangeFund(), amount.mul(core.exchangeFee()));\n        baks.mint(core.developmentFund(), amount.mul(core.developmentFee()));\n    }\n\n    function listCollateralToken(IERC20 token, uint256 initialLoanToValueRatio) external onlyGovernor {\n        if (collateralTokensSet.contains(address(token))) {\n            revert BaksDAOCollateralTokenAlreadyListed(token);\n        }\n\n        if (initialLoanToValueRatio >= core.marginCallLoanToValueRatio()) {\n            revert BaksDAOInitialLoanToValueRatioTooHigh(token, initialLoanToValueRatio);\n        }\n\n        uint8 decimals = token.decimals();\n        if (decimals == 0) {\n            revert BaksDAOCollateralTokenZeroDecimals(token);\n        }\n        if (decimals > DECIMALS) {\n            revert BaksDAOCollateralTokenTooLargeDecimals(token, decimals);\n        }\n\n        if (collateralTokensSet.add(address(token))) {\n            collateralTokens[token] = CollateralToken.Data({\n                collateralToken: token,\n                priceOracle: IPriceOracle(core.priceOracle()),\n                stabilityFee: core.stabilityFee(),\n                stabilizationFee: core.stabilizationFee(),\n                exchangeFee: core.exchangeFee(),\n                developmentFee: core.developmentFee(),\n                initialLoanToValueRatio: initialLoanToValueRatio,\n                marginCallLoanToValueRatio: core.marginCallLoanToValueRatio(),\n                liquidationLoanToValueRatio: core.liquidationLoanToValueRatio(),\n                collateralAmount: 0\n            });\n\n            emit CollateralTokenListed(token);\n            emit InitialLoanToValueRatioUpdated(token, 0, initialLoanToValueRatio);\n        }\n    }\n\n    function unlistCollateralToken(IERC20 token) external onlyGovernor {\n        if (!collateralTokensSet.contains(address(token))) {\n            revert BaksDAOCollateralTokenNotListed(token);\n        }\n\n        if (collateralTokensSet.remove(address(token))) {\n            delete collateralTokens[token];\n            emit CollateralTokenUnlisted(token);\n        }\n    }\n\n    function setInitialLoanToValueRatio(IERC20 token, uint256 newInitialLoanToValueRatio) external onlyGovernor {\n        if (!collateralTokensSet.contains(address(token))) {\n            revert BaksDAOCollateralTokenNotListed(token);\n        }\n\n        CollateralToken.Data storage collateralToken = collateralTokens[token];\n        if (newInitialLoanToValueRatio >= collateralToken.marginCallLoanToValueRatio) {\n            revert BaksDAOInitialLoanToValueRatioTooHigh(token, newInitialLoanToValueRatio);\n        }\n\n        uint256 initialLoanToValueRatio = collateralToken.initialLoanToValueRatio;\n        collateralToken.initialLoanToValueRatio = newInitialLoanToValueRatio;\n\n        emit InitialLoanToValueRatioUpdated(token, initialLoanToValueRatio, newInitialLoanToValueRatio);\n    }\n\n    function salvage(IERC20 token) external onlyGovernor {\n        address tokenAddress = address(token);\n        if (tokenAddress == core.baks() || collateralTokensSet.contains(tokenAddress)) {\n            revert BaksDAOTokenNotAllowedToBeSalvaged(token);\n        }\n        token.safeTransfer(core.operator(), token.balanceOf(address(this)));\n    }\n\n    function getLoans(address borrower) external view returns (Loan.Data[] memory _loans) {\n        uint256 length = loanIds[borrower].length;\n        _loans = new Loan.Data[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            _loans[i] = loans[loanIds[borrower][i]];\n        }\n    }\n\n    function getAllowedCollateralTokens()\n        external\n        view\n        returns (CollateralToken.Data[] memory allowedCollateralTokens)\n    {\n        uint256 length = collateralTokensSet.elements.length;\n        allowedCollateralTokens = new CollateralToken.Data[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            allowedCollateralTokens[i] = collateralTokens[IERC20(collateralTokensSet.elements[i])];\n        }\n    }\n\n    function calculateLoanByPrincipalAmount(IERC20 collateralToken, uint256 principalAmount)\n        public\n        view\n        returns (\n            Loan.Data memory loan,\n            uint256 exchangeFee,\n            uint256 developmentFee,\n            uint256 stabilityFee\n        )\n    {\n        return collateralTokens[collateralToken].calculateLoanByPrincipalAmount(principalAmount);\n    }\n\n    function calculateLoanByCollateralAmount(IERC20 collateralToken, uint256 collateralAmount)\n        public\n        view\n        returns (\n            Loan.Data memory loan,\n            uint256 exchangeFee,\n            uint256 developmentFee,\n            uint256 stabilityFee\n        )\n    {\n        return collateralTokens[collateralToken].calculateLoanByCollateralAmount(collateralAmount);\n    }\n\n    function calculateLoanBySecurityAmount(IERC20 collateralToken, uint256 securityAmount)\n        public\n        view\n        returns (\n            Loan.Data memory loan,\n            uint256 exchangeFee,\n            uint256 developmentFee,\n            uint256 stabilityFee\n        )\n    {\n        return collateralTokens[collateralToken].calculateLoanBySecurityAmount(securityAmount);\n    }\n\n    function getTotalValueLocked() public view returns (uint256 totalValueLocked) {\n        for (uint256 i = 0; i < collateralTokensSet.elements.length; i++) {\n            totalValueLocked += collateralTokens[IERC20(collateralTokensSet.elements[i])].getCollateralValue();\n        }\n        totalValueLocked += IDepositary(core.depositary()).getTotalValueLocked();\n    }\n\n    function getLoanToValueRatio(uint256 loanId) public view returns (uint256 loanToValueRatio) {\n        Loan.Data memory loan = loans[loanId];\n        loanToValueRatio = loan.calculateLoanToValueRatio();\n    }\n\n    function getLoanAccruedInterest(uint256 loanId) public view returns (uint256 accruedInterest) {\n        Loan.Data memory loan = loans[loanId];\n        accruedInterest = loan.calculateInterest();\n    }\n\n    function checkHealth(uint256 loanId) public view returns (Health health) {\n        uint256 loanToValueRatio = getLoanToValueRatio(loanId);\n        health = loanToValueRatio >= core.liquidationLoanToValueRatio()\n            ? Health.Liquidation\n            : loanToValueRatio >= core.marginCallLoanToValueRatio()\n            ? Health.MarginCall\n            : Health.Ok;\n    }\n\n    function _createLoan(\n        Loan.Data memory loan,\n        uint256 exchangeFee,\n        uint256 developmentFee\n    ) internal returns (Loan.Data memory) {\n        if (loan.principalAmount == 0) {\n            revert BaksDAOBorrowZeroAmount();\n        }\n        if (loan.principalAmount < core.minimumPrincipalAmount()) {\n            revert BaksDAOBorrowBelowMinimumPrincipalAmount();\n        }\n\n        IMintableAndBurnableERC20 baks = IMintableAndBurnableERC20(core.baks());\n        baks.mint(address(this), loan.stabilizationFee);\n        baks.mint(core.exchangeFund(), exchangeFee);\n        baks.mint(core.developmentFund(), developmentFee);\n        baks.mint(loan.borrower, loan.principalAmount);\n\n        uint256 id = loans.length;\n        loan.id = id;\n        loan.interest = core.interest();\n\n        loans.push(loan);\n        loanIds[loan.borrower].push(id);\n\n        collateralTokens[loan.collateralToken].collateralAmount += loan.collateralAmount;\n\n        emit Borrow(\n            id,\n            loan.borrower,\n            loan.collateralToken,\n            loan.principalAmount,\n            loan.collateralAmount,\n            collateralTokens[loan.collateralToken].initialLoanToValueRatio\n        );\n\n        return loan;\n    }\n\n    function _deposit(uint256 loanId, uint256 amount) internal {\n        if (amount == 0) {\n            revert BaksDAODepositZeroAmount();\n        }\n\n        Loan.Data storage loan = loans[loanId];\n        loan.accrueInterest();\n\n        uint256 normalizedCollateralAmount = loan.collateralToken.normalizeAmount(amount);\n        loan.collateralAmount += normalizedCollateralAmount;\n        loan.lastInteractionAt = block.timestamp;\n        collateralTokens[loan.collateralToken].collateralAmount += normalizedCollateralAmount;\n\n        emit Deposit(loanId, normalizedCollateralAmount);\n    }\n}\n"
    },
    "contracts/libraries/CollateralToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./FixedPointMath.sol\";\nimport \"./Loan.sol\";\nimport {IERC20} from \"./../interfaces/ERC20.sol\";\nimport {IPriceOracle} from \"./../interfaces/IPriceOracle.sol\";\n\nlibrary CollateralToken {\n    using FixedPointMath for uint256;\n\n    struct Data {\n        IERC20 collateralToken;\n        IPriceOracle priceOracle;\n        uint256 stabilityFee;\n        uint256 stabilizationFee;\n        uint256 exchangeFee;\n        uint256 developmentFee;\n        uint256 initialLoanToValueRatio;\n        uint256 marginCallLoanToValueRatio;\n        uint256 liquidationLoanToValueRatio;\n        uint256 collateralAmount;\n    }\n\n    uint256 internal constant ONE = 100e16;\n\n    function calculateLoanByPrincipalAmount(Data memory self, uint256 principalAmount)\n        internal\n        view\n        returns (\n            Loan.Data memory loan,\n            uint256 exchangeFee,\n            uint256 developmentFee,\n            uint256 stabilityFee\n        )\n    {\n        uint256 collateralTokenPrice = self.priceOracle.getNormalizedPrice(self.collateralToken);\n\n        uint256 restOfIssuance = principalAmount.mul(ONE - self.initialLoanToValueRatio).div(\n            self.initialLoanToValueRatio\n        );\n        uint256 stabilizationFee = restOfIssuance.mul(self.stabilizationFee);\n        exchangeFee = restOfIssuance.mul(self.exchangeFee);\n        developmentFee = restOfIssuance.mul(self.developmentFee);\n\n        uint256 collateralAmount = principalAmount.div(self.initialLoanToValueRatio.mul(collateralTokenPrice));\n        stabilityFee = self.stabilityFee.mul(principalAmount).div(collateralTokenPrice);\n\n        loan = Loan.Data({\n            id: 0,\n            isActive: true,\n            borrower: msg.sender,\n            collateralToken: self.collateralToken,\n            isNativeCurrency: false,\n            priceOracle: self.priceOracle,\n            interest: 0,\n            stabilizationFee: stabilizationFee,\n            principalAmount: principalAmount,\n            interestAmount: 0,\n            collateralAmount: collateralAmount,\n            lastInteractionAt: block.timestamp\n        });\n    }\n\n    function calculateLoanByCollateralAmount(Data memory self, uint256 collateralAmount)\n        internal\n        view\n        returns (\n            Loan.Data memory loan,\n            uint256 exchangeFee,\n            uint256 developmentFee,\n            uint256 stabilityFee\n        )\n    {\n        uint256 collateralTokenPrice = self.priceOracle.getNormalizedPrice(self.collateralToken);\n        uint256 principalAmount = collateralAmount.mul(self.initialLoanToValueRatio).mul(collateralTokenPrice);\n\n        uint256 restOfIssuance = principalAmount.mul(ONE - self.initialLoanToValueRatio).div(\n            self.initialLoanToValueRatio\n        );\n        uint256 stabilizationFee = restOfIssuance.mul(self.stabilizationFee);\n        exchangeFee = restOfIssuance.mul(self.exchangeFee);\n        developmentFee = restOfIssuance.mul(self.developmentFee);\n\n        stabilityFee = self.stabilityFee.mul(principalAmount).div(collateralTokenPrice);\n\n        loan = Loan.Data({\n            id: 0,\n            isActive: true,\n            borrower: msg.sender,\n            collateralToken: self.collateralToken,\n            isNativeCurrency: false,\n            priceOracle: self.priceOracle,\n            stabilizationFee: stabilizationFee,\n            interest: 0,\n            principalAmount: principalAmount,\n            interestAmount: 0,\n            collateralAmount: collateralAmount,\n            lastInteractionAt: block.timestamp\n        });\n    }\n\n    function calculateLoanBySecurityAmount(Data memory self, uint256 securityAmount)\n        internal\n        view\n        returns (\n            Loan.Data memory loan,\n            uint256 exchangeFee,\n            uint256 developmentFee,\n            uint256 stabilityFee\n        )\n    {\n        uint256 collateralTokenPrice = self.priceOracle.getNormalizedPrice(self.collateralToken);\n        uint256 c = self.stabilityFee.mul(self.initialLoanToValueRatio);\n        uint256 principalAmount = securityAmount.mul(self.initialLoanToValueRatio).mul(collateralTokenPrice).div(\n            c + ONE\n        );\n        return calculateLoanByPrincipalAmount(self, principalAmount);\n    }\n\n    function getCollateralValue(Data memory self) internal view returns (uint256 collateralValue) {\n        if (self.collateralAmount == 0) {\n            return 0;\n        }\n\n        uint256 collateralTokenPrice = self.priceOracle.getNormalizedPrice(self.collateralToken);\n        collateralValue = self.collateralAmount.mul(collateralTokenPrice);\n    }\n}\n"
    },
    "contracts/libraries/Loan.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nimport \"./FixedPointMath.sol\";\nimport \"./Math.sol\";\nimport {IERC20} from \"./../interfaces/ERC20.sol\";\nimport {IPriceOracle} from \"./../interfaces/IPriceOracle.sol\";\n\nlibrary Loan {\n    using FixedPointMath for uint256;\n\n    struct Data {\n        uint256 id;\n        bool isActive;\n        address borrower;\n        IERC20 collateralToken;\n        bool isNativeCurrency;\n        IPriceOracle priceOracle;\n        uint256 interest;\n        uint256 stabilizationFee;\n        uint256 principalAmount;\n        uint256 interestAmount;\n        uint256 collateralAmount;\n        uint256 lastInteractionAt;\n    }\n\n    uint256 internal constant ONE = 100e16;\n    uint256 internal constant SECONDS_PER_YEAR = 31557600;\n\n    function accrueInterest(Data storage self) internal {\n        self.interestAmount += calculateInterest(self);\n    }\n\n    function calculateInterest(Data memory self) internal view returns (uint256 interest) {\n        interest = self.principalAmount.mul(self.interest).mul(\n            (block.timestamp - self.lastInteractionAt).mulDiv(ONE, SECONDS_PER_YEAR)\n        );\n    }\n\n    function getCollateralValue(Data memory self) internal view returns (uint256 collateralValue) {\n        uint256 collateralTokenPrice = self.priceOracle.getNormalizedPrice(self.collateralToken);\n        collateralValue = self.collateralAmount.mul(collateralTokenPrice);\n    }\n\n    function calculateLoanToValueRatio(Data memory self) internal view returns (uint256 loanToValueRatio) {\n        if (self.principalAmount == 0) {\n            return 0;\n        }\n        if (self.collateralAmount == 0) {\n            return type(uint256).max;\n        }\n\n        loanToValueRatio = (self.principalAmount + calculateInterest(self)).div(getCollateralValue(self));\n    }\n}\n"
    },
    "contracts/libraries/MintingStage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.10;\n\nlibrary MintingStage {\n    function split(uint256 mintingStage) internal pure returns (uint256 totalValueLocked, uint256 amount) {\n        amount = mintingStage & type(uint128).max;\n        totalValueLocked = mintingStage >> 128;\n    }\n}\n"
    },
    "contracts/libraries/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nerror ReentrancyGuardReentrantCall();\n\nabstract contract ReentrancyGuard {\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private status;\n\n    modifier nonReentrant() {\n        if (status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        status = ENTERED;\n\n        _;\n\n        status = NOT_ENTERED;\n    }\n\n    function initializeReentrancyGuard() internal {\n        status = NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/test/TestMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\nimport \"./../libraries/Math.sol\";\n\ncontract TestMath {\n    using Math for uint256;\n    using Math for int256;\n\n    function _abs(int256 a) external pure returns (uint256) {\n        return a.abs();\n    }\n\n    function _sqrt(uint256 x) external pure returns (uint256 result) {\n        return x.sqrt();\n    }\n\n    function _fpsqrt(uint256 a) external pure returns (uint256 result) {\n        return a.fpsqrt();\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}