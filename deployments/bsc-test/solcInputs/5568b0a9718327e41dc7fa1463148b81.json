{
  "language": "Solidity",
  "sources": {
    "contracts/$.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport {BaseToken, MinterZeroAddress} from \"./BaseToken.sol\";\nimport {Governed} from \"./Governance.sol\";\nimport \"./interfaces/IEIP2612.sol\";\n\ncontract Baks is Governed, BaseToken {\n    event MinterChanged(address indexed minter, address indexed newMinter);\n\n    constructor(address minter) BaseToken(\"Baks\", \"BAKS\", 18, \"1\", minter) {}\n\n    function setMinter(address newMinter) external onlyGovernor {\n        if (newMinter == address(0)) {\n            revert MinterZeroAddress();\n        }\n        minter = newMinter;\n        emit MinterChanged(minter, newMinter);\n    }\n}\n"
    },
    "contracts/BaseToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport {IMintableAndBurnableERC20} from \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IEIP2612.sol\";\n\nerror ApproveFromZeroAddress(address spender, uint256 amount);\nerror ApproveToZeroAddress(address owner, uint256 amount);\n\nerror MintToZeroAddress(uint256 amount);\n\nerror BurnFromZeroAddress(uint256 amount);\nerror BurnAmountExceedsBalance(address from, uint256 amount, uint256 balance);\n\nerror TransferFromZeroAddress(address to, uint256 amount);\nerror TransferToZeroAddress(address from, uint256 amount);\nerror TransferAmountExceedsAllowance(address from, address to, uint256 amount, uint256 allowance);\nerror TransferAmountExceedsBalance(address from, address to, uint256 amount, uint256 balance);\n\nerror MinterZeroAddress();\nerror OnlyMinterAllowed();\n\nerror EIP2612PermissionExpired(uint256 deadline);\nerror EIP2612InvalidSignature(address owner, address signer);\n\ncontract BaseToken is IMintableAndBurnableERC20, IEIP2612 {\n    bytes32 private constant EIP_712_DOMAIN_TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    bytes32 private constant PERMIT_TYPE_HASH =\n        keccak256(\"Permit(address owner,address spender,uint256 amount,uint256 nonce,uint256 deadline)\");\n\n    string public override name;\n    string public override symbol;\n    uint8 public override decimals;\n    string public version;\n\n    uint256 public override totalSupply;\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    address public minter;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 public immutable override DOMAIN_SEPARATOR;\n    mapping(address => uint256) public override nonces;\n\n    modifier onlyMinter() {\n        if (msg.sender != minter) {\n            revert OnlyMinterAllowed();\n        }\n        _;\n    }\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        string memory _version,\n        address _minter\n    ) {\n        if (_minter == address(0)) {\n            revert MinterZeroAddress();\n        }\n        minter = _minter;\n\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        version = _version;\n\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                EIP_712_DOMAIN_TYPE_HASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool) {\n        if (from != msg.sender) {\n            uint256 _allowance = allowance[from][msg.sender];\n            if (_allowance < amount) {\n                revert TransferAmountExceedsAllowance(from, to, amount, _allowance);\n            }\n        }\n\n        _transfer(from, to, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) external override returns (bool) {\n        _transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function mint(address to, uint256 amount) external override onlyMinter {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) external override onlyMinter {\n        _burn(from, amount);\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        if (deadline < block.timestamp) {\n            revert EIP2612PermissionExpired(deadline);\n        }\n\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPE_HASH, owner, spender, amount, nonces[owner]++, deadline))\n            )\n        );\n        address signer = ecrecover(hash, v, r, s);\n        if (signer != owner) {\n            revert EIP2612InvalidSignature(owner, signer);\n        }\n        _approve(owner, spender, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal {\n        if (owner == address(0)) {\n            revert ApproveFromZeroAddress(spender, amount);\n        }\n        if (spender == address(0)) {\n            revert ApproveToZeroAddress(owner, amount);\n        }\n\n        allowance[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n    }\n\n    function _mint(address to, uint256 amount) internal {\n        if (to == address(0)) {\n            revert MintToZeroAddress(amount);\n        }\n\n        balanceOf[to] += amount;\n        totalSupply += amount;\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) internal {\n        if (from == address(0)) {\n            revert BurnFromZeroAddress(amount);\n        }\n\n        uint256 balance = balanceOf[from];\n        if (balance < amount) {\n            revert BurnAmountExceedsBalance(from, amount, balance);\n        }\n        unchecked {\n            balanceOf[from] = balance - amount;\n        }\n        totalSupply -= amount;\n\n        emit Transfer(from, address(0), amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (from == address(0)) {\n            revert TransferFromZeroAddress(to, amount);\n        }\n        if (to == address(0)) {\n            revert TransferToZeroAddress(from, amount);\n        }\n\n        uint256 balance = balanceOf[from];\n        if (balance < amount) {\n            revert TransferAmountExceedsBalance(from, to, amount, balance);\n        }\n        unchecked {\n            balanceOf[from] = balance - amount;\n        }\n        balanceOf[to] += amount;\n\n        emit Transfer(from, to, amount);\n    }\n}\n"
    },
    "contracts/Governance.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nerror GovernedOnlyGovernorAllowedToCall();\nerror GovernedOnlyPendingGovernorAllowedToCall();\nerror GovernedGovernorZeroAddress();\nerror GovernedCantGoverItself();\n\nabstract contract Governed {\n    address public governor;\n    address public pendingGovernor;\n\n    event PendingGovernanceTransition(address indexed governor, address indexed newGovernor);\n    event GovernanceTransited(address indexed governor, address indexed newGovernor);\n\n    modifier onlyGovernor() {\n        if (msg.sender != governor) {\n            revert GovernedOnlyGovernorAllowedToCall();\n        }\n        _;\n    }\n\n    constructor() {\n        governor = msg.sender;\n        emit PendingGovernanceTransition(address(0), governor);\n        emit GovernanceTransited(address(0), governor);\n    }\n\n    function transitGovernance(address newGovernor) external onlyGovernor {\n        if (newGovernor == address(0)) {\n            revert GovernedGovernorZeroAddress();\n        }\n        if (newGovernor == address(this)) {\n            revert GovernedCantGoverItself();\n        }\n\n        pendingGovernor = newGovernor;\n        emit PendingGovernanceTransition(governor, newGovernor);\n    }\n\n    function acceptGovernance() external {\n        if (msg.sender != pendingGovernor) {\n            revert GovernedOnlyPendingGovernorAllowedToCall();\n        }\n\n        governor = pendingGovernor;\n        emit GovernanceTransited(governor, pendingGovernor);\n    }\n}\n"
    },
    "contracts/interfaces/IEIP2612.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./IERC20.sol\";\n\ninterface IEIP2612 is IERC20 {\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n\ninterface IMintableAndBurnableERC20 is IERC20 {\n    function mint(address to, uint256 amount) external;\n\n    function burn(address from, uint256 amount) external;\n}\n"
    },
    "contracts/test/DummyPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.9;\n\nimport \"./../interfaces/IERC20.sol\";\nimport \"./../libraries/FixedPointMath.sol\";\nimport {Governed} from \"./../Governance.sol\";\nimport \"./../interfaces/IPriceOracle.sol\";\n\ncontract DummyPriceOracle is Governed, IPriceOracle {\n    IERC20 public immutable wrappedNativeCurrency;\n\n    mapping(IERC20 => uint256) public prices;\n\n    constructor(IERC20 _wrappedNativeCurrency) {\n        wrappedNativeCurrency = _wrappedNativeCurrency;\n    }\n\n    function setPrice(IERC20 token, uint256 price) external onlyGovernor {\n        prices[token] = price;\n    }\n\n    function getNormalizedPrice(IERC20 token) external view override returns (uint256 normalizedPrice) {\n        normalizedPrice = prices[token];\n    }\n}\n"
    },
    "contracts/libraries/FixedPointMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nerror FixedPointMathMulDivOverflow(uint256 prod1, uint256 denominator);\n\n/// @title Fixed point math implementation\nlibrary FixedPointMath {\n    uint256 internal constant SCALE = 1e18;\n    /// @dev Largest power of two divisor of scale.\n    uint256 internal constant SCALE_LPOTD = 262144;\n    /// @dev Scale inverted mod 2**256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661508869554232690281;\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert FixedPointMathMulDivOverflow(prod1, SCALE);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(a, b, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            assembly {\n                result := add(div(prod0, SCALE), roundUpUnit)\n            }\n            return result;\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256 result) {\n        result = mulDiv(a, SCALE, b);\n    }\n\n    /// @notice Calculates ⌊a × b ÷ denominator⌋ with full precision.\n    /// @dev Credit to Remco Bloemen under MIT license https://2π.com/21/muldiv.\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= denominator) {\n            revert FixedPointMathMulDivOverflow(prod1, denominator);\n        }\n\n        if (prod1 == 0) {\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        unchecked {\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, lpotdod)\n                prod0 := div(prod0, lpotdod)\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n            prod0 |= prod1 * lpotdod;\n\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n\n            result = prod0 * inverse;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./IERC20.sol\";\nimport \"./../libraries/FixedPointMath.sol\";\n\n/// @notice Thrown when oracle doesn't provide price for `token` token.\n/// @param token The address of the token contract.\nerror PriceOracleTokenUnknown(IERC20 token);\n/// @notice Thrown when oracle provide stale price `price` for `token` token.\n/// @param token The address of the token contract.\n/// @param price Provided price.\nerror PriceOracleStalePrice(IERC20 token, uint256 price);\n/// @notice Thrown when oracle provide negative, zero or in other ways invalid price `price` for `token` token.\n/// @param token The address of the token contract.\n/// @param price Provided price.\nerror PriceOracleInvalidPrice(IERC20 token, int256 price);\n\ninterface IPriceOracle {\n    /// @notice Gets normalized to 18 decimals price for the `token` token.\n    /// @param token The address of the token contract.\n    /// @return normalizedPrice Normalized price.\n    function getNormalizedPrice(IERC20 token) external view returns (uint256 normalizedPrice);\n}\n"
    },
    "contracts/ExchangeFund.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport \"./libraries/AmountNormalization.sol\";\nimport \"./libraries/EnumerableAddressSet.sol\";\nimport \"./libraries/FixedPointMath.sol\";\nimport \"./libraries/ReentrancyGuard.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport {Governed} from \"./Governance.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport {IPriceOracle} from \"./interfaces/IPriceOracle.sol\";\nimport {IUniswapV2Factory, IUniswapV2Router, IUniswapV2Pair} from \"./interfaces/UniswapV2.sol\";\n\n/// @dev Thrown when trying to list depositable token that has zero decimals.\n/// @param token The address of the token contract.\nerror ExchangeFundDepositableTokenZeroDecimals(IERC20 token);\n\n/// @dev Thrown when trying to list depositable token that has too large decimals.\n/// @param token The address of the token contract.\nerror ExchangeFundDepositableTokenTooLargeDecimals(IERC20 token, uint8 decimals);\n\n/// @dev Thrown when trying to list depositable token that's already listed.\n/// @param token The address of the token contract.\nerror ExchangeFundDepositableTokenAlreadyListed(IERC20 token);\n\n/// @dev Thrown when trying to unlist depositable token that's not listed.\n/// @param token The address of the token contract.\nerror ExchangeFundDepositableTokenNotListed(IERC20 token);\n\n/// @dev Thrown when interacting with a token that's not allowed to be deposited.\n/// @param token The address of the token contract.\nerror ExchangeFundTokenNotAllowedToBeDeposited(IERC20 token);\n\n/// @dev Thrown when interacting with a token that's not allowed to be withdrawn.\n/// @param token The address of the token contract.\nerror ExchangeFundTokenNotAllowedToBeWithdrawn(IERC20 token);\n\n/// @dev Thrown when trying to salvage one of depositable tokens or stablecoin.\n/// @param token The address of the token contract.\nerror ExchangeFundTokenNotAllowedToBeSalvaged(IERC20 token);\n\nerror ExchangeFundInsufficientDeposits();\n\nerror ExchangeFundInsufficientLiquidity();\n\nerror ExchangeFundSameTokenSwap(IERC20 token);\n\n/// @dev Thrown when trying to swap token that's not allowed to be swapped.\n/// @param token The address of the token contract.\nerror ExchangeFundTokenNotAllowedToBeSwapped(IERC20 token);\n\ncontract ExchangeFund is Governed, ReentrancyGuard {\n    using AmountNormalization for IERC20;\n    using EnumerableAddressSet for EnumerableAddressSet.Set;\n    using FixedPointMath for uint256;\n    using SafeERC20 for IERC20;\n\n    uint256 internal constant ONE = 100e16;\n    uint8 internal constant DECIMALS = 18;\n\n    IERC20 public immutable wrappedNativeCurrency;\n\n    IERC20 public immutable stablecoin;\n    IPriceOracle public immutable priceOracle;\n    IUniswapV2Router public immutable uniswapV2Router;\n\n    address public immutable operator;\n\n    uint256 public slippageTolerance = 5e15; // 0.5 %\n    uint256 public swapDeadline = 20 minutes;\n\n    mapping(address => mapping(IERC20 => uint256)) public deposits;\n    mapping(address => mapping(IERC20 => uint256)) public liquidity;\n\n    mapping(IERC20 => bool) public depositableTokens;\n    EnumerableAddressSet.Set internal depositableTokensSet;\n\n    event DepositableTokenListed(IERC20 indexed token, IUniswapV2Pair pair);\n    event DepositableTokenUnlisted(IERC20 indexed token);\n\n    event SlippageToleranceUpdated(uint256 slippageTolerance, uint256 newSlippageTolerance);\n    event SwapDeadlineUpdated(uint256 swapDeadline, uint256 newSwapDeadline);\n\n    event Deposit(address indexed account, IERC20 indexed token, uint256 amount);\n    event Swap(address indexed account, IERC20 indexed tokenA, IERC20 indexed tokenB, uint256 amountA, uint256 amountB);\n    event Invest(address indexed account, IERC20 indexed token, uint256 amount);\n    event Divest(address indexed account, IERC20 indexed token, uint256 amount);\n    event Withdrawal(address indexed account, IERC20 indexed token, uint256 amount);\n\n    modifier tokenAllowedToBeDeposited(IERC20 token) {\n        if (!depositableTokensSet.contains(address(token))) {\n            revert ExchangeFundTokenNotAllowedToBeDeposited(token);\n        }\n        _;\n    }\n\n    modifier tokenAllowedToBeSwapped(IERC20 token) {\n        if (token != stablecoin && !depositableTokensSet.contains(address(token))) {\n            revert ExchangeFundTokenNotAllowedToBeSwapped(token);\n        }\n        _;\n    }\n\n    constructor(\n        IERC20 _wrappedNativeCurrency,\n        IERC20 _stablecoin,\n        IPriceOracle _priceOracle,\n        IUniswapV2Router _uniswapV2Router,\n        address _operator\n    ) {\n        wrappedNativeCurrency = _wrappedNativeCurrency;\n\n        stablecoin = _stablecoin;\n        priceOracle = _priceOracle;\n        uniswapV2Router = _uniswapV2Router;\n        operator = _operator;\n\n        _stablecoin.approve(address(_uniswapV2Router), type(uint256).max);\n    }\n\n    function deposit(IERC20 token, uint256 amount) external nonReentrant tokenAllowedToBeDeposited(token) {\n        token.safeTransferFrom(msg.sender, address(this), amount);\n\n        uint256 normalizedAmount = token.normalizeAmount(amount);\n        deposits[msg.sender][token] += normalizedAmount;\n\n        emit Deposit(msg.sender, token, normalizedAmount);\n    }\n\n    function swap(\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint256 amount,\n        bool useWrappedNativeCurrencyAsIntermediateToken\n    ) external nonReentrant tokenAllowedToBeSwapped(tokenA) tokenAllowedToBeSwapped(tokenB) {\n        uint256 normalizedAmount = tokenA.normalizeAmount(amount);\n        if (normalizedAmount > deposits[msg.sender][tokenA]) {\n            revert ExchangeFundInsufficientDeposits();\n        }\n\n        if (tokenA == tokenB) {\n            revert ExchangeFundSameTokenSwap(tokenA);\n        }\n\n        address[] memory path = new address[](useWrappedNativeCurrencyAsIntermediateToken ? 3 : 2);\n        path[0] = address(tokenA);\n        path[1] = useWrappedNativeCurrencyAsIntermediateToken ? address(wrappedNativeCurrency) : address(tokenB);\n        if (useWrappedNativeCurrencyAsIntermediateToken) {\n            path[2] = address(tokenB);\n        }\n\n        uint256[] memory amounts = uniswapV2Router.getAmountsOut(amount, path);\n        uint256 normalizedAmountOut = tokenB.normalizeAmount(amounts[amounts.length - 1]);\n\n        amounts = uniswapV2Router.swapExactTokensForTokens(\n            amount,\n            tokenB.denormalizeAmount(normalizedAmountOut.mul(ONE - slippageTolerance)),\n            path,\n            address(this),\n            block.timestamp + swapDeadline\n        );\n\n        uint256 normalizedTokenAAmount = tokenA.normalizeAmount(amounts[0]);\n        uint256 normalizedTokenBAmount = tokenB.normalizeAmount(amounts[amounts.length - 1]);\n\n        deposits[msg.sender][tokenA] -= normalizedTokenAAmount;\n        deposits[msg.sender][tokenB] += normalizedTokenBAmount;\n\n        emit Swap(msg.sender, tokenA, tokenB, normalizedTokenAAmount, normalizedTokenBAmount);\n    }\n\n    function invest(IERC20 token, uint256 amount) external nonReentrant {\n        uint256 normalizedAmount = token.normalizeAmount(amount);\n        if (normalizedAmount > deposits[msg.sender][token]) {\n            revert ExchangeFundInsufficientDeposits();\n        }\n\n        uint256 tokenValue = quote(token, amount);\n        (, uint256 amountSent, uint256 liquidityMinted) = uniswapV2Router.addLiquidity(\n            stablecoin,\n            token,\n            tokenValue,\n            amount,\n            tokenValue.mul(ONE - slippageTolerance),\n            token.denormalizeAmount(normalizedAmount.mul(ONE - slippageTolerance)),\n            address(this),\n            block.timestamp + swapDeadline\n        );\n\n        deposits[msg.sender][token] -= token.normalizeAmount(amountSent);\n        liquidity[msg.sender][token] += liquidityMinted;\n\n        emit Invest(msg.sender, token, normalizedAmount);\n    }\n\n    function divest(IERC20 token, uint256 amount) external nonReentrant {\n        if (amount > liquidity[msg.sender][token]) {\n            revert ExchangeFundInsufficientLiquidity();\n        }\n\n        (, uint256 amountReceived) = uniswapV2Router.removeLiquidity(\n            stablecoin,\n            token,\n            amount,\n            0,\n            0,\n            address(this),\n            block.timestamp + swapDeadline\n        );\n\n        deposits[msg.sender][token] += token.normalizeAmount(amountReceived);\n        liquidity[msg.sender][token] -= amount;\n\n        emit Divest(msg.sender, token, amount);\n    }\n\n    function withdraw(IERC20 token, uint256 amount) external nonReentrant {\n        if (token == stablecoin) {\n            revert ExchangeFundTokenNotAllowedToBeWithdrawn(token);\n        }\n\n        uint256 normalizedAmount = token.normalizeAmount(amount);\n        if (normalizedAmount > deposits[msg.sender][token]) {\n            revert ExchangeFundInsufficientDeposits();\n        }\n\n        deposits[msg.sender][token] -= normalizedAmount;\n        token.safeTransfer(msg.sender, amount);\n\n        emit Withdrawal(msg.sender, token, normalizedAmount);\n    }\n\n    function listDepositableToken(IERC20 token) external onlyGovernor {\n        if (depositableTokensSet.contains(address(token))) {\n            revert ExchangeFundDepositableTokenAlreadyListed(token);\n        }\n\n        uint8 decimals = token.decimals();\n        if (decimals == 0) {\n            revert ExchangeFundDepositableTokenZeroDecimals(token);\n        }\n        if (decimals > DECIMALS) {\n            revert ExchangeFundDepositableTokenTooLargeDecimals(token, decimals);\n        }\n\n        if (depositableTokensSet.add(address(token))) {\n            token.approve(address(uniswapV2Router), type(uint256).max);\n\n            IUniswapV2Factory uniswapV2Factory = uniswapV2Router.factory();\n            IUniswapV2Pair uniswapV2Pair = uniswapV2Factory.getPair(stablecoin, token);\n            if (address(uniswapV2Pair) == address(0)) {\n                uniswapV2Pair = uniswapV2Factory.createPair(stablecoin, token);\n            }\n            uniswapV2Pair.approve(address(uniswapV2Router), type(uint256).max);\n\n            depositableTokens[token] = true;\n            emit DepositableTokenListed(token, uniswapV2Pair);\n        }\n    }\n\n    function unlistDepositableToken(IERC20 token) external onlyGovernor {\n        if (!depositableTokensSet.contains(address(token))) {\n            revert ExchangeFundDepositableTokenNotListed(token);\n        }\n\n        if (depositableTokensSet.remove(address(token))) {\n            token.approve(address(uniswapV2Router), 0);\n\n            IUniswapV2Factory uniswapV2Factory = uniswapV2Router.factory();\n            IUniswapV2Pair uniswapV2Pair = uniswapV2Factory.getPair(stablecoin, token);\n            if (address(uniswapV2Pair) != address(0)) {\n                uniswapV2Pair.approve(address(uniswapV2Router), 0);\n            }\n\n            delete depositableTokens[token];\n            emit DepositableTokenUnlisted(token);\n        }\n    }\n\n    function setSlippageTolerance(uint256 newSlippageTolerance) external onlyGovernor {\n        emit SlippageToleranceUpdated(slippageTolerance, newSlippageTolerance);\n        slippageTolerance = newSlippageTolerance;\n    }\n\n    function setSwapDeadline(uint256 newSwapDeadline) external onlyGovernor {\n        emit SwapDeadlineUpdated(swapDeadline, newSwapDeadline);\n        swapDeadline = newSwapDeadline;\n    }\n\n    function salvage(IERC20 token) external onlyGovernor {\n        address tokenAddress = address(token);\n        if (token == stablecoin || depositableTokensSet.contains(tokenAddress)) {\n            revert ExchangeFundTokenNotAllowedToBeSalvaged(token);\n        }\n        token.safeTransfer(operator, token.balanceOf(address(this)));\n    }\n\n    function getDepositableTokens() external view returns (IERC20[] memory tokens) {\n        uint256 length = depositableTokensSet.elements.length;\n        tokens = new IERC20[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            tokens[i] = IERC20(depositableTokensSet.elements[i]);\n        }\n    }\n\n    function quote(IERC20 token, uint256 amount) public view returns (uint256 stablecoinAmount) {\n        IUniswapV2Pair uniswapV2Pair = uniswapV2Router.factory().getPair(stablecoin, token);\n\n        (uint256 reserveA, uint256 reserveB, ) = uniswapV2Pair.getReserves();\n        if (reserveA == 0 || reserveB == 0) {\n            stablecoinAmount = token.normalizeAmount(amount).mul(priceOracle.getNormalizedPrice(token));\n            return stablecoinAmount;\n        }\n\n        stablecoinAmount = address(stablecoin) < address(token)\n            ? uniswapV2Router.quote(amount, reserveB, reserveA)\n            : uniswapV2Router.quote(amount, reserveA, reserveB);\n    }\n}\n"
    },
    "contracts/libraries/AmountNormalization.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./../interfaces/IERC20.sol\";\n\nlibrary AmountNormalization {\n    uint8 internal constant DECIMALS = 18;\n\n    function normalizeAmount(IERC20 self, uint256 denormalizedAmount) internal view returns (uint256 normalizedAmount) {\n        uint256 scale = 10**(DECIMALS - self.decimals());\n        if (scale != 1) {\n            return denormalizedAmount * scale;\n        }\n        return denormalizedAmount;\n    }\n\n    function denormalizeAmount(IERC20 self, uint256 normalizedAmount)\n        internal\n        view\n        returns (uint256 denormalizedAmount)\n    {\n        uint256 scale = 10**(DECIMALS - self.decimals());\n        if (scale != 1) {\n            return normalizedAmount / scale;\n        }\n        return normalizedAmount;\n    }\n}\n"
    },
    "contracts/libraries/EnumerableAddressSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nlibrary EnumerableAddressSet {\n    struct Set {\n        address[] elements;\n        mapping(address => uint256) indexes;\n    }\n\n    function add(Set storage self, address element) internal returns (bool) {\n        if (contains(self, element)) {\n            return false;\n        }\n\n        self.elements.push(element);\n        self.indexes[element] = self.elements.length;\n\n        return true;\n    }\n\n    function remove(Set storage self, address element) internal returns (bool) {\n        uint256 elementIndex = indexOf(self, element);\n        if (elementIndex == 0) {\n            return false;\n        }\n\n        uint256 indexToRemove = elementIndex - 1;\n        uint256 lastIndex = count(self) - 1;\n        if (indexToRemove != lastIndex) {\n            address lastElement = self.elements[lastIndex];\n            self.elements[indexToRemove] = lastElement;\n            self.indexes[lastElement] = elementIndex;\n        }\n        self.elements.pop();\n        delete self.indexes[element];\n\n        return true;\n    }\n\n    function indexOf(Set storage self, address element) internal view returns (uint256) {\n        return self.indexes[element];\n    }\n\n    function contains(Set storage self, address element) internal view returns (bool) {\n        return indexOf(self, element) != 0;\n    }\n\n    function count(Set storage self) internal view returns (uint256) {\n        return self.elements.length;\n    }\n}\n"
    },
    "contracts/libraries/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nerror ReentrancyGuardReentrantCall();\n\nabstract contract ReentrancyGuard {\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private status;\n\n    modifier nonReentrant() {\n        if (status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        status = ENTERED;\n\n        _;\n\n        status = NOT_ENTERED;\n    }\n\n    constructor() {\n        status = NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./../interfaces/IERC20.sol\";\nimport \"./Address.sol\";\n\nerror SafeERC20NoReturnData();\n\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        callWithOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, amount));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        callWithOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, amount));\n    }\n\n    function callWithOptionalReturn(IERC20 token, bytes memory data) internal {\n        address tokenAddress = address(token);\n\n        bytes memory returnData = tokenAddress.functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returnData.length > 0) {\n            if (!abi.decode(returnData, (bool))) {\n                revert SafeERC20NoReturnData();\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/UniswapV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.9;\n\nimport {IERC20} from \"./IERC20.sol\";\n\ninterface IUniswapV2Factory {\n    function createPair(IERC20 tokenA, IERC20 tokenB) external returns (IUniswapV2Pair pair);\n\n    function getPair(IERC20 tokenA, IERC20 tokenB) external view returns (IUniswapV2Pair pair);\n}\n\ninterface IUniswapV2Pair is IERC20 {\n    function token0() external view returns (IERC20);\n\n    function token1() external view returns (IERC20);\n\n    function getReserves()\n        external\n        view\n        returns (\n            uint112 reserve0,\n            uint112 reserve1,\n            uint32 blockTimestampLast\n        );\n}\n\ninterface IUniswapV2Router {\n    function addLiquidity(\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function removeLiquidity(\n        IERC20 tokenA,\n        IERC20 tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path) external view returns (uint256[] memory amounts);\n\n    function factory() external view returns (IUniswapV2Factory);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n}\n"
    },
    "contracts/libraries/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nerror CallToNonContract(address target);\n\nlibrary Address {\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        if (!isContract(target)) {\n            revert CallToNonContract(target);\n        }\n\n        (bool success, bytes memory returnData) = target.call(data);\n        return verifyCallResult(success, returnData, errorMessage);\n    }\n\n    function delegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        if (!isContract(target)) {\n            revert CallToNonContract(target);\n        }\n\n        (bool success, bytes memory returnData) = target.delegatecall(data);\n        return verifyCallResult(success, returnData, errorMessage);\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(account)\n        }\n\n        return codeSize > 0;\n    }\n\n    function verifyCallResult(\n        bool success,\n        bytes memory returnData,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returnData;\n        } else {\n            if (returnData.length > 0) {\n                assembly {\n                    let returnDataSize := mload(returnData)\n                    revert(add(returnData, 32), returnDataSize)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/InvestmentFund.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport {Governed} from \"./Governance.sol\";\n\ncontract InvestmentFund is Governed {}\n"
    },
    "contracts/ChainlinkPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport \"./interfaces/IChainlinkAggregator.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./libraries/FixedPointMath.sol\";\nimport {Governed} from \"./Governance.sol\";\nimport \"./interfaces/IPriceOracle.sol\";\n\ncontract ChainlinkPriceOracle is Governed, IPriceOracle {\n    using FixedPointMath for uint256;\n\n    uint256 internal constant DIRECT_CONVERSION_PATH_SCALE = 1e10;\n    uint256 internal constant INTERMEDIATE_CONVERSION_PATH_SCALE = 1e8;\n\n    IERC20 public immutable wrappedNativeCurrency;\n\n    mapping(IERC20 => IChainlinkAggregator) public nativeAggregators;\n    mapping(IERC20 => IChainlinkAggregator) public usdAggregators;\n\n    event AggregatorSet(IERC20 token, IChainlinkAggregator aggregator, bool isQuoteNative);\n\n    constructor(IERC20 _wrappedNativeCurrency) {\n        wrappedNativeCurrency = _wrappedNativeCurrency;\n    }\n\n    function setAggregator(\n        IERC20 token,\n        IChainlinkAggregator aggregator,\n        bool isQuoteNative\n    ) external onlyGovernor {\n        if (isQuoteNative) {\n            nativeAggregators[token] = aggregator;\n        } else {\n            usdAggregators[token] = aggregator;\n        }\n\n        emit AggregatorSet(token, aggregator, isQuoteNative);\n    }\n\n    function getNormalizedPrice(IERC20 token) external view override returns (uint256 normalizedPrice) {\n        IChainlinkAggregator aggregator = usdAggregators[token];\n        if (address(aggregator) == address(0)) {\n            uint256 tokenToNativeCurrencyPrice = getTokenToNativeCurrencyPrice(token);\n            uint256 nativeCurrencyToUsdPrice = getNativeCurrencyToUsdPrice();\n            return tokenToNativeCurrencyPrice.mulDiv(nativeCurrencyToUsdPrice, INTERMEDIATE_CONVERSION_PATH_SCALE);\n        }\n\n        normalizedPrice = getLatestPrice(token, aggregator) * DIRECT_CONVERSION_PATH_SCALE;\n    }\n\n    function getTokenToNativeCurrencyPrice(IERC20 token) internal view returns (uint256 price) {\n        IChainlinkAggregator aggregator = nativeAggregators[token];\n        if (address(aggregator) == address(0)) {\n            revert PriceOracleTokenUnknown(token);\n        }\n\n        price = getLatestPrice(token, aggregator);\n    }\n\n    function getNativeCurrencyToUsdPrice() internal view returns (uint256 price) {\n        IChainlinkAggregator aggregator = usdAggregators[wrappedNativeCurrency];\n        if (address(aggregator) == address(0)) {\n            revert PriceOracleTokenUnknown(wrappedNativeCurrency);\n        }\n\n        price = getLatestPrice(wrappedNativeCurrency, aggregator);\n    }\n\n    function getLatestPrice(IERC20 token, IChainlinkAggregator aggregator) internal view returns (uint256 price) {\n        (uint80 roundId, int256 answer, , , uint80 answeredInRound) = aggregator.latestRoundData();\n        if (answer <= 0) {\n            revert PriceOracleInvalidPrice(token, answer);\n        }\n\n        price = uint256(answer);\n        if (answeredInRound < roundId) {\n            revert PriceOracleStalePrice(token, price);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IChainlinkAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\ninterface IChainlinkAggregator {\n    function decimals() external view returns (uint8);\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "contracts/libraries/Loan.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport \"./FixedPointMath.sol\";\nimport {IERC20} from \"./../interfaces/IERC20.sol\";\nimport {IPriceOracle} from \"./../interfaces/IPriceOracle.sol\";\n\nlibrary Loan {\n    using FixedPointMath for uint256;\n\n    struct Data {\n        uint256 id;\n        bool isActive;\n        address borrower;\n        IERC20 collateralToken;\n        bool isNativeCurrency;\n        IPriceOracle priceOracle;\n        uint256 stabilityFee;\n        uint256 stabilizationFee;\n        uint256 exchangeFee;\n        uint256 investmentFee;\n        uint256 principalAmount;\n        uint256 collateralAmount;\n        uint256 lastDepositAt;\n        uint256 lastRepaymentAt;\n    }\n\n    function getCollateralValue(Data memory self) internal view returns (uint256 collateralValue) {\n        uint256 collateralTokenPrice = self.priceOracle.getNormalizedPrice(self.collateralToken);\n        collateralValue = self.collateralAmount.mul(collateralTokenPrice);\n    }\n\n    function calculateLoanToValueRatio(Data memory self) internal view returns (uint256 loanToValueRatio) {\n        if (self.principalAmount == 0) {\n            return 0;\n        }\n        if (self.collateralAmount == 0) {\n            return type(uint256).max;\n        }\n\n        loanToValueRatio = self.principalAmount.div(getCollateralValue(self));\n    }\n}\n"
    },
    "contracts/libraries/CollateralToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport \"./FixedPointMath.sol\";\nimport \"./Loan.sol\";\nimport {IERC20} from \"./../interfaces/IERC20.sol\";\nimport {IPriceOracle} from \"./../interfaces/IPriceOracle.sol\";\n\nlibrary CollateralToken {\n    using FixedPointMath for uint256;\n\n    struct Data {\n        IERC20 collateralToken;\n        IPriceOracle priceOracle;\n        uint256 stabilityFee;\n        uint256 stabilizationFee;\n        uint256 exchangeFee;\n        uint256 investmentFee;\n        uint256 initialLoanToValueRatio;\n        uint256 marginCallLoanToValueRatio;\n        uint256 liquidationLoanToValueRatio;\n        uint256 collateralAmount;\n    }\n\n    uint256 internal constant ONE = 100e16;\n\n    function calculateLoanByPrincipalAmount(Data memory self, uint256 principalAmount)\n        public\n        view\n        returns (Loan.Data memory)\n    {\n        uint256 collateralTokenPrice = self.priceOracle.getNormalizedPrice(self.collateralToken);\n\n        uint256 restOfIssuance = principalAmount.mul(ONE - self.initialLoanToValueRatio).div(\n            self.initialLoanToValueRatio\n        );\n        uint256 stabilizationFee = restOfIssuance.mul(self.stabilizationFee);\n        uint256 exchangeFee = restOfIssuance.mul(self.exchangeFee);\n        uint256 investmentFee = restOfIssuance.mul(self.investmentFee);\n\n        uint256 collateralAmount = principalAmount.div(self.initialLoanToValueRatio.mul(collateralTokenPrice));\n        uint256 stabilityFee = self.stabilityFee.mul(principalAmount).div(collateralTokenPrice);\n\n        return\n            Loan.Data({\n                id: 0,\n                isActive: true,\n                borrower: msg.sender,\n                collateralToken: self.collateralToken,\n                isNativeCurrency: false,\n                priceOracle: self.priceOracle,\n                stabilityFee: stabilityFee,\n                stabilizationFee: stabilizationFee,\n                exchangeFee: exchangeFee,\n                investmentFee: investmentFee,\n                principalAmount: principalAmount,\n                collateralAmount: collateralAmount,\n                lastDepositAt: block.timestamp,\n                lastRepaymentAt: block.timestamp\n            });\n    }\n\n    function calculateLoanByCollateralAmount(Data memory self, uint256 collateralAmount)\n        public\n        view\n        returns (Loan.Data memory)\n    {\n        uint256 collateralTokenPrice = self.priceOracle.getNormalizedPrice(self.collateralToken);\n        uint256 principalAmount = collateralAmount.mul(self.initialLoanToValueRatio).mul(collateralTokenPrice);\n\n        uint256 restOfIssuance = principalAmount.mul(ONE - self.initialLoanToValueRatio).div(\n            self.initialLoanToValueRatio\n        );\n        uint256 stabilizationFee = restOfIssuance.mul(self.stabilizationFee);\n        uint256 exchangeFee = restOfIssuance.mul(self.exchangeFee);\n        uint256 investmentFee = restOfIssuance.mul(self.investmentFee);\n\n        uint256 stabilityFee = self.stabilityFee.mul(principalAmount).div(collateralTokenPrice);\n\n        return\n            Loan.Data({\n                id: 0,\n                isActive: true,\n                borrower: msg.sender,\n                collateralToken: self.collateralToken,\n                isNativeCurrency: false,\n                priceOracle: self.priceOracle,\n                stabilityFee: stabilityFee,\n                stabilizationFee: stabilizationFee,\n                exchangeFee: exchangeFee,\n                investmentFee: investmentFee,\n                principalAmount: principalAmount,\n                collateralAmount: collateralAmount,\n                lastDepositAt: block.timestamp,\n                lastRepaymentAt: block.timestamp\n            });\n    }\n\n    function calculateLoanBySecurityAmount(Data memory self, uint256 securityAmount)\n        public\n        view\n        returns (Loan.Data memory)\n    {\n        uint256 collateralTokenPrice = self.priceOracle.getNormalizedPrice(self.collateralToken);\n        uint256 c = self.stabilityFee.mul(self.initialLoanToValueRatio);\n        uint256 principalAmount = securityAmount.mul(self.initialLoanToValueRatio).mul(collateralTokenPrice).div(\n            c + ONE\n        );\n        return calculateLoanByPrincipalAmount(self, principalAmount);\n    }\n\n    function getCollateralValue(Data memory self) internal view returns (uint256 collateralValue) {\n        uint256 collateralTokenPrice = self.priceOracle.getNormalizedPrice(self.collateralToken);\n        collateralValue = self.collateralAmount.mul(collateralTokenPrice);\n    }\n}\n"
    },
    "contracts/BaksDAO.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.9;\n\nimport \"./interfaces/IWrappedNativeCurrency.sol\";\nimport \"./libraries/AmountNormalization.sol\";\nimport \"./libraries/CollateralToken.sol\";\nimport \"./libraries/EnumerableAddressSet.sol\";\nimport \"./libraries/FixedPointMath.sol\";\nimport \"./libraries/Loan.sol\";\nimport \"./libraries/Math.sol\";\nimport \"./libraries/ReentrancyGuard.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport {Governed} from \"./Governance.sol\";\nimport {IERC20, IMintableAndBurnableERC20} from \"./interfaces/IERC20.sol\";\nimport {IPriceOracle} from \"./interfaces/IPriceOracle.sol\";\n\n/// @dev Thrown when trying to list collateral token that has zero decimals.\n/// @param token The address of the collateral token contract.\nerror BaksDAOCollateralTokenZeroDecimals(IERC20 token);\n\n/// @dev Thrown when trying to list collateral token that has too large decimals.\n/// @param token The address of the collateral token contract.\nerror BaksDAOCollateralTokenTooLargeDecimals(IERC20 token, uint8 decimals);\n\n/// @dev Thrown when trying to list collateral token that's already listed.\n/// @param token The address of the collateral token contract.\nerror BaksDAOCollateralTokenAlreadyListed(IERC20 token);\n\n/// @dev Thrown when trying to unlist collateral token that's not listed.\n/// @param token The address of the collateral token contract.\nerror BaksDAOCollateralTokenNotListed(IERC20 token);\n\n/// @dev Thrown when interacting with a token that's not allowed as collateral.\n/// @param token The address of the collateral token contract.\nerror BaksDAOTokenNotAllowedAsCollateral(IERC20 token);\n\n/// @dev Thrown when trying to set initial loan-to-value ratio that higher than margin call or liquidation ones.\n/// @param token The address of the collateral token contract.\n/// @param initialLoanToValueRatio The initial loan-to-value ratio that was tried to set.\nerror BaksDAOInitialLoanToValueRatioTooHigh(IERC20 token, uint256 initialLoanToValueRatio);\n\n/// @dev Thrown when trying to set platform fees that don't sum up to one.\n/// @param stabilizationFee The stabilization fee that was tried to set.\n/// @param exchangeFee The stabilization fee that was tried to set.\n/// @param investmentFee The stabilization fee that was tried to set.\nerror BaksDAOPlatformFeesDontSumUpToOne(uint256 stabilizationFee, uint256 exchangeFee, uint256 investmentFee);\n\n/// @dev Thrown when trying to interact with inactive loan with `id` id.\n/// @param id The loan id.\nerror BaksDAOInactiveLoan(uint256 id);\n\n/// @dev Thrown when trying to liquidate healthy loan with `id` id.\n/// @param id The loan id.\nerror BaksDAOLoanNotSubjectToLiquidation(uint256 id);\n/// @dev Thrown when trying to interact with loan with `id` id that is subject to liquidation.\n/// @param id The loan id.\nerror BaksDAOLoanIsSubjectToLiquidation(uint256 id);\n\n/// @dev Thrown when borrowing a zero amount of stablecoin.\nerror BaksDAOBorrowZeroAmount();\n\n/// @dev Thrown when trying to borrow below minimum principal amount.\nerror BaksDAOBorrowBelowMinimumPrincipalAmount();\n\n/// @dev Thrown when depositing a zero amount of collateral token.\nerror BaksDAODepositZeroAmount();\n\n/// @dev Thrown when repaying a zero amount of stablecoin.\nerror BaksDAORepayZeroAmount();\n\n/// @dev Thrown when there's no need to rebalance the platform.\nerror BaksDAONoNeedToRebalance();\n\n/// @dev Thrown when trying to rebalance the platform and there is a shortage of funds to burn.\n/// @param shortage Shoratge of funds to burn.\nerror BaksDAOStabilizationFundOutOfFunds(uint256 shortage);\n\n/// @dev Thrown when trying to salvage one of allowed collateral tokens or stablecoin.\n/// @param token The address of the token contract.\nerror BaksDAOTokenNotAllowedToBeSalvaged(IERC20 token);\n\n/// @dev Thrown when trying to deposit native currency collateral to the non-wrapped native currency token loan\n/// with `id` id.\n/// @param id The loan id.\nerror BaksDAONativeCurrencyCollateralNotAllowed(uint256 id);\n\nerror BaksDAONativeCurrencyTransferFailed();\n\nerror BaksDAOPlainNativeCurrencyTransferNotAllowed();\n\nerror BaksDAOInsufficientSecurityAmount(uint256 minimumRequiredSecurityAmount);\n\n/// @title Core smart contract of BaksDAO platform\n/// @author Andrey Gulitsky\n/// @notice You should use this contract to interact with the BaksDAO platform.\n/// @notice Only this contract can issue stablecoins.\ncontract BaksDAO is Governed, ReentrancyGuard {\n    using AmountNormalization for IERC20;\n    using AmountNormalization for IWrappedNativeCurrency;\n    using CollateralToken for CollateralToken.Data;\n    using EnumerableAddressSet for EnumerableAddressSet.Set;\n    using FixedPointMath for uint256;\n    using Loan for Loan.Data;\n    using SafeERC20 for IWrappedNativeCurrency;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IMintableAndBurnableERC20;\n\n    enum Health {\n        Ok,\n        MarginCall,\n        Liquidation\n    }\n\n    uint256 internal constant ONE = 100e16;\n    uint8 internal constant DECIMALS = 18;\n\n    IWrappedNativeCurrency public immutable wrappedNativeCurrency;\n    IMintableAndBurnableERC20 public immutable stablecoin;\n    IPriceOracle public immutable priceOracle;\n\n    address public immutable operator;\n    address public immutable liquidator;\n    address public immutable exchangeFund;\n    address public immutable investmentFund;\n\n    uint256 public minimumPrincipalAmount = 50e18; // 50 BAKS\n    uint256 public stabilityFee = 3e16; // 3 %\n    uint256 public stabilizationFee = 85e16; // 85 %\n    uint256 public exchangeFee = 15e16; // 15 %\n    uint256 public investmentFee = 0;\n    uint256 public marginCallLoanToValueRatio = 75e16; // 75 %\n    uint256 public liquidationLoanToValueRatio = 83e16; // 83 %\n    uint256 public rebalancingThreshold = 1e16; // 1 %\n\n    Loan.Data[] public loans;\n    mapping(address => uint256[]) public loanIds;\n\n    mapping(IERC20 => CollateralToken.Data) public collateralTokens;\n    EnumerableAddressSet.Set internal collateralTokensSet;\n\n    event CollateralTokenListed(IERC20 indexed token);\n    event CollateralTokenUnlisted(IERC20 indexed token);\n\n    event MinimumPrincipalAmountUpdated(uint256 minimumPrincipalAmount, uint256 newMinimumPrincipalAmount);\n    event StabilityFeeUpdated(uint256 stabilityFee, uint256 newStabilityFee);\n    event RebalancingThresholdUpdated(uint256 rebalancingThreshold, uint256 newRebalancingThreshold);\n    event PlatformFeesUpdated(\n        uint256 stabilizationFee,\n        uint256 newStabilizationFee,\n        uint256 exchangeFee,\n        uint256 newExchangeFee,\n        uint256 investmentFee,\n        uint256 newInvestmentFee\n    );\n    event MarginCallLoanToValueRatioUpdated(uint256 marginCallLoanToValueRatio, uint256 newMarginCallLoanToValueRatio);\n    event LiquidationLoanToValueRatioUpdated(\n        uint256 liqudationLoanToValueRatio,\n        uint256 newLiquidationLoanToValueRatio\n    );\n    event InitialLoanToValueRatioUpdated(\n        IERC20 indexed token,\n        uint256 initialLoanToValueRatio,\n        uint256 newInitialLoanToValueRatio\n    );\n\n    event Borrow(\n        uint256 indexed id,\n        address indexed borrower,\n        IERC20 indexed token,\n        uint256 principalAmount,\n        uint256 collateralAmount,\n        uint256 initialLoanToValueRatio\n    );\n    event Deposit(uint256 indexed id, uint256 collateralAmount);\n    event Repay(uint256 indexed id, uint256 principalAmount);\n    event Repaid(uint256 indexed id);\n\n    event Liquidated(uint256 indexed id);\n\n    event Rebalance(int256 delta);\n\n    modifier tokenAllowedAsCollateral(IERC20 token) {\n        if (!collateralTokensSet.contains(address(token))) {\n            revert BaksDAOTokenNotAllowedAsCollateral(token);\n        }\n        _;\n    }\n\n    modifier onActiveLoan(uint256 id) {\n        if (id >= loans.length || !loans[id].isActive) {\n            revert BaksDAOInactiveLoan(id);\n        }\n        _;\n    }\n\n    modifier notOnSubjectToLiquidation(uint256 loanId) {\n        if (checkHealth(loanId) == Health.Liquidation) {\n            revert BaksDAOLoanIsSubjectToLiquidation(loanId);\n        }\n        _;\n    }\n\n    modifier onSubjectToLiquidation(uint256 loanId) {\n        if (checkHealth(loanId) != Health.Liquidation) {\n            revert BaksDAOLoanNotSubjectToLiquidation(loanId);\n        }\n        _;\n    }\n\n    constructor(\n        IWrappedNativeCurrency _wrappedNativeCurrency,\n        IMintableAndBurnableERC20 _stablecoin,\n        IPriceOracle _priceOracle,\n        address _operator,\n        address _liquidator,\n        address _exchangeFund,\n        address _investmentFund\n    ) {\n        wrappedNativeCurrency = _wrappedNativeCurrency;\n        stablecoin = _stablecoin;\n        priceOracle = _priceOracle;\n        operator = _operator;\n        liquidator = _liquidator;\n        exchangeFund = _exchangeFund;\n        investmentFund = _investmentFund;\n    }\n\n    receive() external payable {\n        if (msg.sender != address(wrappedNativeCurrency)) {\n            revert BaksDAOPlainNativeCurrencyTransferNotAllowed();\n        }\n    }\n\n    /// @notice Increases loan's principal on `collateralToken` collateral token and mints `amount` of stablecoin.\n    /// @dev The caller must have allowed this contract to spend a sufficient amount of collateral tokens to cover\n    /// initial loan-to-value ratio.\n    /// @param collateralToken The address of the collateral token contract.\n    /// @param amount The amount of stablecoin to borrow and issue.\n    function borrow(IERC20 collateralToken, uint256 amount)\n        external\n        nonReentrant\n        tokenAllowedAsCollateral(collateralToken)\n        returns (Loan.Data memory)\n    {\n        Loan.Data memory loan = calculateLoanByPrincipalAmount(collateralToken, amount);\n\n        collateralToken.safeTransferFrom(msg.sender, operator, collateralToken.denormalizeAmount(loan.stabilityFee));\n        collateralToken.safeTransferFrom(\n            msg.sender,\n            address(this),\n            collateralToken.denormalizeAmount(loan.collateralAmount)\n        );\n\n        return _createLoan(loan);\n    }\n\n    /// @notice Increases loan's principal on wrapped native currency token and mints stablecoin.\n    function borrowInNativeCurrency(uint256 amount) external payable nonReentrant returns (Loan.Data memory) {\n        Loan.Data memory loan = calculateLoanByPrincipalAmount(wrappedNativeCurrency, amount);\n        loan.isNativeCurrency = true;\n\n        uint256 securityAmount = loan.collateralAmount + loan.stabilityFee;\n        if (msg.value < securityAmount) {\n            revert BaksDAOInsufficientSecurityAmount(securityAmount);\n        }\n\n        wrappedNativeCurrency.deposit{value: securityAmount}();\n        wrappedNativeCurrency.safeTransfer(operator, wrappedNativeCurrency.denormalizeAmount(loan.stabilityFee));\n\n        uint256 change;\n        unchecked {\n            change = msg.value - securityAmount;\n        }\n        if (change > 0) {\n            (bool success, ) = msg.sender.call{value: change}(\"\");\n            if (!success) {\n                revert BaksDAONativeCurrencyTransferFailed();\n            }\n        }\n\n        return _createLoan(loan);\n    }\n\n    /// @notice Deposits `amount` of collateral token to loan with `id` id.\n    /// @dev The caller must have allowed this contract to spend `amount` of collateral tokens.\n    /// @param loanId The loan id.\n    /// @param amount The amount of collateral token to deposit.\n    function deposit(uint256 loanId, uint256 amount)\n        external\n        nonReentrant\n        onActiveLoan(loanId)\n        notOnSubjectToLiquidation(loanId)\n    {\n        loans[loanId].collateralToken.safeTransferFrom(msg.sender, address(this), amount);\n        _deposit(loanId, amount);\n    }\n\n    /// @notice Deposits wrapped native currency token to loan with `id` id.\n    function depositInNativeCurrency(uint256 loanId)\n        external\n        payable\n        nonReentrant\n        onActiveLoan(loanId)\n        notOnSubjectToLiquidation(loanId)\n    {\n        if (loans[loanId].collateralToken != wrappedNativeCurrency) {\n            revert BaksDAONativeCurrencyCollateralNotAllowed(loanId);\n        }\n        wrappedNativeCurrency.deposit{value: msg.value}();\n        _deposit(loanId, msg.value);\n    }\n\n    /// @notice Decreases principal of loan with `id` id by `amount` of stablecoin.\n    /// @param loanId The loan id.\n    /// @param amount The amount of stablecoin to repay.\n    function repay(uint256 loanId, uint256 amount)\n        external\n        nonReentrant\n        onActiveLoan(loanId)\n        notOnSubjectToLiquidation(loanId)\n    {\n        if (amount == 0) {\n            revert BaksDAORepayZeroAmount();\n        }\n        Loan.Data storage loan = loans[loanId];\n        loan.principalAmount -= amount;\n\n        stablecoin.burn(msg.sender, amount);\n        loan.lastRepaymentAt = block.timestamp;\n        if (loan.principalAmount > 0) {\n            emit Repay(loanId, amount);\n        } else {\n            uint256 denormalizedCollateralAmount = loan.collateralToken.denormalizeAmount(loan.collateralAmount);\n            collateralTokens[loan.collateralToken].collateralAmount -= loan.collateralAmount;\n\n            loan.collateralAmount = 0;\n\n            stablecoin.burn(address(this), loan.stabilizationFee);\n\n            loan.isActive = false;\n            emit Repaid(loanId);\n\n            if (!loan.isNativeCurrency) {\n                loan.collateralToken.safeTransfer(loan.borrower, denormalizedCollateralAmount);\n            } else {\n                wrappedNativeCurrency.withdraw(denormalizedCollateralAmount);\n                (bool success, ) = msg.sender.call{value: denormalizedCollateralAmount}(\"\");\n                if (!success) {\n                    revert BaksDAONativeCurrencyTransferFailed();\n                }\n            }\n        }\n    }\n\n    function liquidate(uint256 loanId) external nonReentrant onActiveLoan(loanId) onSubjectToLiquidation(loanId) {\n        Loan.Data storage loan = loans[loanId];\n\n        collateralTokens[loan.collateralToken].collateralAmount -= loan.collateralAmount;\n        loan.collateralToken.safeTransfer(liquidator, loan.collateralToken.denormalizeAmount(loan.collateralAmount));\n\n        uint256 collateralValue = loan.getCollateralValue();\n        stablecoin.burn(liquidator, loan.principalAmount);\n        stablecoin.burn(address(this), collateralValue - loan.principalAmount);\n\n        loan.isActive = false;\n        emit Liquidated(loanId);\n    }\n\n    function rebalance() external nonReentrant {\n        uint256 totalValueLocked = getTotalValueLocked();\n        uint256 totalSupply = stablecoin.totalSupply();\n\n        int256 delta = int256(totalSupply) - int256(totalValueLocked);\n        uint256 absoluteDelta = Math.abs(delta);\n        uint256 p = absoluteDelta.div(totalSupply);\n        if (p < rebalancingThreshold) {\n            revert BaksDAONoNeedToRebalance();\n        }\n\n        if (delta > 0) {\n            try stablecoin.burn(address(this), absoluteDelta) {} catch {\n                uint256 balance = stablecoin.balanceOf(address(this));\n                revert BaksDAOStabilizationFundOutOfFunds(absoluteDelta - balance);\n            }\n        } else {\n            stablecoin.mint(address(this), absoluteDelta);\n        }\n\n        emit Rebalance(delta);\n    }\n\n    function listCollateralToken(IERC20 token, uint256 initialLoanToValueRatio) external onlyGovernor {\n        if (collateralTokensSet.contains(address(token))) {\n            revert BaksDAOCollateralTokenAlreadyListed(token);\n        }\n\n        if (initialLoanToValueRatio >= marginCallLoanToValueRatio) {\n            revert BaksDAOInitialLoanToValueRatioTooHigh(token, initialLoanToValueRatio);\n        }\n\n        uint8 decimals = token.decimals();\n        if (decimals == 0) {\n            revert BaksDAOCollateralTokenZeroDecimals(token);\n        }\n        if (decimals > DECIMALS) {\n            revert BaksDAOCollateralTokenTooLargeDecimals(token, decimals);\n        }\n\n        if (collateralTokensSet.add(address(token))) {\n            collateralTokens[token] = CollateralToken.Data({\n                collateralToken: token,\n                priceOracle: priceOracle,\n                stabilityFee: stabilityFee,\n                stabilizationFee: stabilizationFee,\n                exchangeFee: exchangeFee,\n                investmentFee: investmentFee,\n                initialLoanToValueRatio: initialLoanToValueRatio,\n                marginCallLoanToValueRatio: marginCallLoanToValueRatio,\n                liquidationLoanToValueRatio: liquidationLoanToValueRatio,\n                collateralAmount: 0\n            });\n\n            emit CollateralTokenListed(token);\n            emit InitialLoanToValueRatioUpdated(token, 0, initialLoanToValueRatio);\n        }\n    }\n\n    function unlistCollateralToken(IERC20 token) external onlyGovernor {\n        if (!collateralTokensSet.contains(address(token))) {\n            revert BaksDAOCollateralTokenNotListed(token);\n        }\n\n        if (collateralTokensSet.remove(address(token))) {\n            delete collateralTokens[token];\n            emit CollateralTokenUnlisted(token);\n        }\n    }\n\n    function setMinimumPrincipalAmount(uint256 newMinimumPrincipalAmount) external onlyGovernor {\n        emit StabilityFeeUpdated(minimumPrincipalAmount, newMinimumPrincipalAmount);\n        minimumPrincipalAmount = newMinimumPrincipalAmount;\n    }\n\n    function setStabilityFee(uint256 newStabilityFee) external onlyGovernor {\n        emit StabilityFeeUpdated(stabilityFee, newStabilityFee);\n        stabilityFee = newStabilityFee;\n    }\n\n    function setPlatformFees(\n        uint256 newStabilizationFee,\n        uint256 newExchangeFee,\n        uint256 newInvestmentFee\n    ) external onlyGovernor {\n        if (newStabilizationFee + newExchangeFee + newInvestmentFee != ONE) {\n            revert BaksDAOPlatformFeesDontSumUpToOne(newStabilizationFee, newExchangeFee, newInvestmentFee);\n        }\n        emit PlatformFeesUpdated(\n            stabilizationFee,\n            newStabilizationFee,\n            exchangeFee,\n            newExchangeFee,\n            investmentFee,\n            newInvestmentFee\n        );\n        stabilizationFee = newStabilizationFee;\n        exchangeFee = newExchangeFee;\n        investmentFee = newInvestmentFee;\n    }\n\n    function setMarginCallLoanToValueRatio(uint256 newMarginCallLoanToValueRatio) external onlyGovernor {\n        emit MarginCallLoanToValueRatioUpdated(marginCallLoanToValueRatio, newMarginCallLoanToValueRatio);\n        marginCallLoanToValueRatio = newMarginCallLoanToValueRatio;\n    }\n\n    function setLiquidationLoanToValueRatio(uint256 newLiquidationLoanToValueRatio) external onlyGovernor {\n        emit LiquidationLoanToValueRatioUpdated(liquidationLoanToValueRatio, newLiquidationLoanToValueRatio);\n        liquidationLoanToValueRatio = newLiquidationLoanToValueRatio;\n    }\n\n    function setRebalancingThreshold(uint256 newRebalancingThreshold) external onlyGovernor {\n        emit RebalancingThresholdUpdated(rebalancingThreshold, newRebalancingThreshold);\n        rebalancingThreshold = newRebalancingThreshold;\n    }\n\n    function setInitialLoanToValueRatio(IERC20 token, uint256 newInitialLoanToValueRatio) external onlyGovernor {\n        if (!collateralTokensSet.contains(address(token))) {\n            revert BaksDAOCollateralTokenNotListed(token);\n        }\n\n        CollateralToken.Data storage collateralToken = collateralTokens[token];\n        if (newInitialLoanToValueRatio >= collateralToken.marginCallLoanToValueRatio) {\n            revert BaksDAOInitialLoanToValueRatioTooHigh(token, newInitialLoanToValueRatio);\n        }\n\n        uint256 initialLoanToValueRatio = collateralToken.initialLoanToValueRatio;\n        collateralToken.initialLoanToValueRatio = newInitialLoanToValueRatio;\n\n        emit InitialLoanToValueRatioUpdated(token, initialLoanToValueRatio, newInitialLoanToValueRatio);\n    }\n\n    function salvage(IERC20 token) external onlyGovernor {\n        address tokenAddress = address(token);\n        if (tokenAddress == address(stablecoin) || collateralTokensSet.contains(tokenAddress)) {\n            revert BaksDAOTokenNotAllowedToBeSalvaged(token);\n        }\n        token.safeTransfer(operator, token.balanceOf(address(this)));\n    }\n\n    function getLoans(address borrower) external view returns (Loan.Data[] memory _loans) {\n        uint256 length = loanIds[borrower].length;\n        _loans = new Loan.Data[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            _loans[i] = loans[loanIds[borrower][i]];\n        }\n    }\n\n    function getAllowedCollateralTokens()\n        external\n        view\n        returns (CollateralToken.Data[] memory allowedCollateralTokens)\n    {\n        uint256 length = collateralTokensSet.elements.length;\n        allowedCollateralTokens = new CollateralToken.Data[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            allowedCollateralTokens[i] = collateralTokens[IERC20(collateralTokensSet.elements[i])];\n        }\n    }\n\n    function calculateLoanByPrincipalAmount(IERC20 collateralToken, uint256 principalAmount)\n        public\n        view\n        returns (Loan.Data memory loan)\n    {\n        loan = collateralTokens[collateralToken].calculateLoanByPrincipalAmount(principalAmount);\n    }\n\n    function calculateLoanByCollateralAmount(IERC20 collateralToken, uint256 collateralAmount)\n        public\n        view\n        returns (Loan.Data memory loan)\n    {\n        loan = collateralTokens[collateralToken].calculateLoanByCollateralAmount(collateralAmount);\n    }\n\n    function calculateLoanBySecurityAmount(IERC20 collateralToken, uint256 securityAmount)\n        public\n        view\n        returns (Loan.Data memory loan)\n    {\n        loan = collateralTokens[collateralToken].calculateLoanBySecurityAmount(securityAmount);\n    }\n\n    function getTotalValueLocked() public view returns (uint256 totalValueLocked) {\n        for (uint256 i = 0; i < collateralTokensSet.elements.length; i++) {\n            totalValueLocked += collateralTokens[IERC20(collateralTokensSet.elements[i])].getCollateralValue();\n        }\n    }\n\n    function getLoanToValueRatio(uint256 loanId) public view returns (uint256 loanToValueRatio) {\n        Loan.Data memory loan = loans[loanId];\n        loanToValueRatio = loan.calculateLoanToValueRatio();\n    }\n\n    function checkHealth(uint256 loanId) public view returns (Health health) {\n        uint256 loanToValueRatio = getLoanToValueRatio(loanId);\n        health = loanToValueRatio >= liquidationLoanToValueRatio\n            ? Health.Liquidation\n            : loanToValueRatio >= marginCallLoanToValueRatio\n            ? Health.MarginCall\n            : Health.Ok;\n    }\n\n    function _createLoan(Loan.Data memory loan) internal returns (Loan.Data memory) {\n        if (loan.principalAmount == 0) {\n            revert BaksDAOBorrowZeroAmount();\n        }\n        if (loan.principalAmount < minimumPrincipalAmount) {\n            revert BaksDAOBorrowBelowMinimumPrincipalAmount();\n        }\n\n        stablecoin.mint(address(this), loan.stabilizationFee);\n        stablecoin.mint(exchangeFund, loan.exchangeFee);\n        stablecoin.mint(investmentFund, loan.investmentFee);\n        stablecoin.mint(loan.borrower, loan.principalAmount);\n\n        uint256 id = loans.length;\n        loan.id = id;\n\n        loans.push(loan);\n        loanIds[loan.borrower].push(id);\n\n        collateralTokens[loan.collateralToken].collateralAmount += loan.collateralAmount;\n\n        emit Borrow(\n            id,\n            loan.borrower,\n            loan.collateralToken,\n            loan.principalAmount,\n            loan.collateralAmount,\n            collateralTokens[loan.collateralToken].initialLoanToValueRatio\n        );\n\n        return loan;\n    }\n\n    function _deposit(uint256 loanId, uint256 amount) internal {\n        if (amount == 0) {\n            revert BaksDAODepositZeroAmount();\n        }\n\n        Loan.Data storage loan = loans[loanId];\n\n        uint256 normalizedCollateralAmount = loan.collateralToken.normalizeAmount(amount);\n        loan.collateralAmount += normalizedCollateralAmount;\n        loan.lastDepositAt = block.timestamp;\n        collateralTokens[loan.collateralToken].collateralAmount += normalizedCollateralAmount;\n\n        emit Deposit(loanId, normalizedCollateralAmount);\n    }\n}\n"
    },
    "contracts/interfaces/IWrappedNativeCurrency.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./IERC20.sol\";\n\ninterface IWrappedNativeCurrency is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256 amount) external;\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nlibrary Math {\n    function abs(int256 a) internal pure returns (uint256) {\n        return a >= 0 ? uint256(a) : uint256(-a);\n    }\n}\n"
    },
    "contracts/libraries/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"./Address.sol\";\n\nerror EIP1967ImplementationIsNotContract(address implementation);\n\nlibrary EIP1967 {\n    using Address for address;\n\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    event Upgraded(address indexed newImplementation);\n\n    function setImplementation(address newImplementation) internal {\n        if (!newImplementation.isContract()) {\n            revert EIP1967ImplementationIsNotContract(newImplementation);\n        }\n\n        assembly {\n            sstore(IMPLEMENTATION_SLOT, newImplementation)\n        }\n\n        emit Upgraded(newImplementation);\n    }\n\n    function getImplementation() internal view returns (address implementation) {\n        assembly {\n            implementation := sload(IMPLEMENTATION_SLOT)\n        }\n    }\n}\n\ncontract Proxy {\n    using Address for address;\n\n    receive() external payable {\n        delegateCall();\n    }\n\n    fallback() external payable {\n        delegateCall();\n    }\n\n    function delegateCall() internal {\n        address implementation = EIP1967.getImplementation();\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n}\n"
    },
    "contracts/test/WrappedNativeCurrency.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.9;\n\nimport \"./../BaseToken.sol\";\nimport \"./../interfaces/IWrappedNativeCurrency.sol\";\n\nerror WrappedNativeCurrencyLowLevelCallFailed();\n\ncontract WrappedNativeCurrency is BaseToken, IWrappedNativeCurrency {\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        string memory _version,\n        address _minter\n    ) BaseToken(_name, _symbol, _decimals, _version, _minter) {}\n\n    function deposit() external payable override {\n        _mint(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 amount) external override {\n        _burn(msg.sender, amount);\n        (bool success, ) = msg.sender.call{value: amount}(\"\");\n        if (!success) {\n            revert WrappedNativeCurrencyLowLevelCallFailed();\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}