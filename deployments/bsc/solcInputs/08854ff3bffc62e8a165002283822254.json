{
  "language": "Solidity",
  "sources": {
    "contracts/$.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.6;\n\nimport {BaseToken, MinterZeroAddress} from \"./BaseToken.sol\";\nimport {Governed} from \"./Governance.sol\";\nimport \"./interfaces/IEIP2612.sol\";\n\ncontract Baks is Governed, BaseToken {\n    event MinterChanged(address indexed minter, address indexed newMinter);\n\n    constructor(address minter) BaseToken(\"Baks\", \"BAKS\", 18, \"1\", minter) {}\n\n    function setMinter(address newMinter) external onlyGovernor {\n        if (newMinter == address(0)) {\n            revert MinterZeroAddress();\n        }\n        minter = newMinter;\n        emit MinterChanged(minter, newMinter);\n    }\n}\n"
    },
    "contracts/BaseToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.6;\n\nimport {IMintableAndBurnableERC20} from \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IEIP2612.sol\";\n\nerror ApproveFromZeroAddress(address spender, uint256 amount);\nerror ApproveToZeroAddress(address owner, uint256 amount);\n\nerror MintToZeroAddress(uint256 amount);\n\nerror BurnFromZeroAddress(uint256 amount);\nerror BurnAmountExceedsBalance(address from, uint256 amount, uint256 balance);\n\nerror TransferFromZeroAddress(address to, uint256 amount);\nerror TransferToZeroAddress(address from, uint256 amount);\nerror TransferAmountExceedsAllowance(address from, address to, uint256 amount, uint256 allowance);\nerror TransferAmountExceedsBalance(address from, address to, uint256 amount, uint256 balance);\n\nerror MinterZeroAddress();\nerror OnlyMinterAllowed();\n\nerror EIP2612PermissionExpired(uint256 deadline);\nerror EIP2612InvalidSignature(address owner, address signer);\n\ncontract BaseToken is IMintableAndBurnableERC20, IEIP2612 {\n    bytes32 private constant EIP_712_DOMAIN_TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n    bytes32 private constant PERMIT_TYPE_HASH =\n        keccak256(\"Permit(address owner,address spender,uint256 amount,uint256 nonce,uint256 deadline)\");\n\n    string public override name;\n    string public override symbol;\n    uint8 public override decimals;\n    string public version;\n\n    uint256 public override totalSupply;\n    mapping(address => uint256) public override balanceOf;\n    mapping(address => mapping(address => uint256)) public override allowance;\n\n    address public minter;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 public immutable override DOMAIN_SEPARATOR;\n    mapping(address => uint256) public override nonces;\n\n    modifier onlyMinter() {\n        if (msg.sender != minter) {\n            revert OnlyMinterAllowed();\n        }\n        _;\n    }\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        string memory _version,\n        address _minter\n    ) {\n        if (_minter == address(0)) {\n            revert MinterZeroAddress();\n        }\n        minter = _minter;\n\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        version = _version;\n\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                EIP_712_DOMAIN_TYPE_HASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                block.chainid,\n                address(this)\n            )\n        );\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external override returns (bool) {\n        if (from != msg.sender) {\n            uint256 _allowance = allowance[from][msg.sender];\n            if (_allowance < amount) {\n                revert TransferAmountExceedsAllowance(from, to, amount, _allowance);\n            }\n        }\n\n        _transfer(from, to, amount);\n\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) external override returns (bool) {\n        _transfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external override returns (bool) {\n        _approve(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function mint(address to, uint256 amount) external override onlyMinter {\n        _mint(to, amount);\n    }\n\n    function burn(address from, uint256 amount) external override onlyMinter {\n        _burn(from, amount);\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        if (deadline < block.timestamp) {\n            revert EIP2612PermissionExpired(deadline);\n        }\n\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPE_HASH, owner, spender, amount, nonces[owner]++, deadline))\n            )\n        );\n        address signer = ecrecover(hash, v, r, s);\n        if (signer != owner) {\n            revert EIP2612InvalidSignature(owner, signer);\n        }\n        _approve(owner, spender, amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) private {\n        if (owner == address(0)) {\n            revert ApproveFromZeroAddress(spender, amount);\n        }\n        if (spender == address(0)) {\n            revert ApproveToZeroAddress(owner, amount);\n        }\n\n        allowance[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n    }\n\n    function _mint(address to, uint256 amount) private {\n        if (to == address(0)) {\n            revert MintToZeroAddress(amount);\n        }\n\n        balanceOf[to] += amount;\n        totalSupply += amount;\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address from, uint256 amount) private {\n        if (from == address(0)) {\n            revert BurnFromZeroAddress(amount);\n        }\n\n        uint256 balance = balanceOf[from];\n        if (balance < amount) {\n            revert BurnAmountExceedsBalance(from, amount, balance);\n        }\n        unchecked {\n            balanceOf[from] = balance - amount;\n        }\n        totalSupply -= amount;\n\n        emit Transfer(from, address(0), amount);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) private {\n        if (from == address(0)) {\n            revert TransferFromZeroAddress(to, amount);\n        }\n        if (to == address(0)) {\n            revert TransferToZeroAddress(from, amount);\n        }\n\n        uint256 balance = balanceOf[from];\n        if (balance < amount) {\n            revert TransferAmountExceedsBalance(from, to, amount, balance);\n        }\n        unchecked {\n            balanceOf[from] = balance - amount;\n        }\n        balanceOf[to] += amount;\n\n        emit Transfer(from, to, amount);\n    }\n}\n"
    },
    "contracts/Governance.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.6;\n\nerror GovernedOnlyGovernorAllowedToCall();\nerror GovernedOnlyPendingGovernorAllowedToCall();\nerror GovernedGovernorZeroAddress();\nerror GovernedCantGoverItself();\n\nabstract contract Governed {\n    address public governor;\n    address public pendingGovernor;\n\n    event PendingGovernanceTransition(address indexed governor, address indexed newGovernor);\n    event GovernanceTransited(address indexed governor, address indexed newGovernor);\n\n    modifier onlyGovernor() {\n        if (msg.sender != governor) {\n            revert GovernedOnlyGovernorAllowedToCall();\n        }\n        _;\n    }\n\n    constructor() {\n        governor = msg.sender;\n        emit PendingGovernanceTransition(address(0), governor);\n        emit GovernanceTransited(address(0), governor);\n    }\n\n    function transitGovernance(address newGovernor) external {\n        if (newGovernor == address(0)) {\n            revert GovernedGovernorZeroAddress();\n        }\n        if (newGovernor == address(this)) {\n            revert GovernedCantGoverItself();\n        }\n\n        pendingGovernor = newGovernor;\n        emit PendingGovernanceTransition(governor, newGovernor);\n    }\n\n    function acceptGovernance() external {\n        if (msg.sender != pendingGovernor) {\n            revert GovernedOnlyPendingGovernorAllowedToCall();\n        }\n\n        governor = pendingGovernor;\n        emit GovernanceTransited(governor, pendingGovernor);\n    }\n}\n"
    },
    "contracts/interfaces/IEIP2612.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.6;\n\nimport \"./IERC20.sol\";\n\ninterface IEIP2612 is IERC20 {\n    function permit(\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.6;\n\ninterface IERC20 {\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n\ninterface IMintableAndBurnableERC20 is IERC20 {\n    function mint(address to, uint256 amount) external;\n\n    function burn(address from, uint256 amount) external;\n}\n"
    },
    "contracts/oracles/ChainlinkPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.6;\n\nimport \"./../interfaces/IChainlinkAggregator.sol\";\nimport \"./../interfaces/IERC20.sol\";\nimport \"./../libraries/FixedPointMath.sol\";\nimport {Governed} from \"./../Governance.sol\";\nimport {IPriceOracle, PriceOracleStalePrice, PriceOracleTokenUnknown, PriceOracleInvalidPrice} from \"./../interfaces/IPriceOracle.sol\";\n\ncontract ChainlinkPriceOracle is Governed, IPriceOracle {\n    using FixedPointMath for uint256;\n\n    uint256 internal constant DIRECT_CONVERSION_PATH_SCALE = 1e10;\n    uint256 internal constant INTERMEDIATE_CONVERSION_PATH_SCALE = 1e8;\n\n    IERC20 public immutable wrappedNativeCurrency;\n\n    mapping(IERC20 => IChainlinkAggregator) public nativeAggregators;\n    mapping(IERC20 => IChainlinkAggregator) public usdAggregators;\n\n    event AggregatorSet(IERC20 token, IChainlinkAggregator aggregator, bool isQuoteNative);\n\n    constructor(IERC20 _wrappedNativeCurrency) {\n        wrappedNativeCurrency = _wrappedNativeCurrency;\n    }\n\n    function setAggregator(\n        IERC20 token,\n        IChainlinkAggregator aggregator,\n        bool isQuoteNative\n    ) external onlyGovernor {\n        if (isQuoteNative) {\n            nativeAggregators[token] = aggregator;\n        } else {\n            usdAggregators[token] = aggregator;\n        }\n\n        emit AggregatorSet(token, aggregator, isQuoteNative);\n    }\n\n    function getNormalizedPrice(IERC20 token) external view override returns (uint256 normalizedPrice) {\n        IChainlinkAggregator aggregator = usdAggregators[token];\n        if (address(aggregator) == address(0)) {\n            uint256 tokenToNativeCurrencyPrice = getTokenToNativeCurrencyPrice(token);\n            uint256 nativeCurrencyToUsdPrice = getNativeCurrencyToUsdPrice();\n            return tokenToNativeCurrencyPrice.mulDiv(nativeCurrencyToUsdPrice, INTERMEDIATE_CONVERSION_PATH_SCALE);\n        }\n\n        normalizedPrice = getLatestPrice(token, aggregator) * DIRECT_CONVERSION_PATH_SCALE;\n    }\n\n    function getTokenToNativeCurrencyPrice(IERC20 token) internal view returns (uint256 price) {\n        IChainlinkAggregator aggregator = nativeAggregators[token];\n        if (address(aggregator) == address(0)) {\n            revert PriceOracleTokenUnknown(token);\n        }\n\n        price = getLatestPrice(token, aggregator);\n    }\n\n    function getNativeCurrencyToUsdPrice() internal view returns (uint256 price) {\n        IChainlinkAggregator aggregator = usdAggregators[wrappedNativeCurrency];\n        if (address(aggregator) == address(0)) {\n            revert PriceOracleTokenUnknown(wrappedNativeCurrency);\n        }\n\n        price = getLatestPrice(wrappedNativeCurrency, aggregator);\n    }\n\n    function getLatestPrice(IERC20 token, IChainlinkAggregator aggregator) internal view returns (uint256 price) {\n        (uint80 roundId, int256 answer, , , uint80 answeredInRound) = aggregator.latestRoundData();\n        if (answer <= 0) {\n            revert PriceOracleInvalidPrice(token, answer);\n        }\n\n        price = uint256(answer);\n        if (answeredInRound < roundId) {\n            revert PriceOracleStalePrice(token, price);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IChainlinkAggregator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.6;\n\ninterface IChainlinkAggregator {\n    function decimals() external view returns (uint8);\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "contracts/libraries/FixedPointMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nerror FixedPointMathMulDivOverflow(uint256 prod1, uint256 denominator);\n\n/// @title Fixed point math implementation\nlibrary FixedPointMath {\n    uint256 internal constant SCALE = 1e18;\n    /// @dev Largest power of two divisor of scale.\n    uint256 internal constant SCALE_LPOTD = 262144;\n    /// @dev Scale inverted mod 2**256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661508869554232690281;\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert FixedPointMathMulDivOverflow(prod1, SCALE);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(a, b, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            assembly {\n                result := add(div(prod0, SCALE), roundUpUnit)\n            }\n            return result;\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256 result) {\n        result = mulDiv(a, SCALE, b);\n    }\n\n    /// @notice Calculates ⌊a × b ÷ denominator⌋ with full precision.\n    /// @dev Credit to Remco Bloemen under MIT license https://2π.com/21/muldiv.\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= denominator) {\n            revert FixedPointMathMulDivOverflow(prod1, denominator);\n        }\n\n        if (prod1 == 0) {\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        unchecked {\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                denominator := div(denominator, lpotdod)\n                prod0 := div(prod0, lpotdod)\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n            prod0 |= prod1 * lpotdod;\n\n            uint256 inverse = (3 * denominator) ^ 2;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n            inverse *= 2 - denominator * inverse;\n\n            result = prod0 * inverse;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.6;\n\nimport \"./../interfaces/IERC20.sol\";\nimport \"./../libraries/FixedPointMath.sol\";\n\n/// @notice Thrown when oracle doesn't provide price for `token` token.\n/// @param token The address of the token contract.\nerror PriceOracleTokenUnknown(IERC20 token);\n/// @notice Thrown when oracle provide stale price `price` for `token` token.\n/// @param token The address of the token contract.\n/// @param price Provided price.\nerror PriceOracleStalePrice(IERC20 token, uint256 price);\n/// @notice Thrown when oracle provide negative, zero or in other ways invalid price `price` for `token` token.\n/// @param token The address of the token contract.\n/// @param price Provided price.\nerror PriceOracleInvalidPrice(IERC20 token, int256 price);\n\ninterface IPriceOracle {\n    /// @notice Gets normalized to 18 decimals price for the `token` token.\n    /// @param token The address of the token contract.\n    /// @return normalizedPrice Normalized price.\n    function getNormalizedPrice(IERC20 token) external view returns (uint256 normalizedPrice);\n}\n"
    },
    "contracts/libraries/Loan.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.6;\n\nimport \"./FixedPointMath.sol\";\nimport {IERC20} from \"./../interfaces/IERC20.sol\";\nimport {IPriceOracle} from \"./../interfaces/IPriceOracle.sol\";\n\nlibrary Loan {\n    using FixedPointMath for uint256;\n\n    struct Data {\n        bool isActive;\n        IERC20 collateralToken;\n        IPriceOracle priceOracle;\n        uint256 stabilityFee;\n        uint256 stabilizationFee;\n        uint256 exchangeFee;\n        uint256 investmentFee;\n        uint256 principalAmount;\n        uint256 collateralAmount;\n        uint256 lastDepositAt;\n        uint256 lastRepaymentAt;\n    }\n\n    function calculateLoanToValueRatio(Data memory self) internal view returns (uint256 loanToValueRatio) {\n        if (self.principalAmount == 0) {\n            return 0;\n        }\n        if (self.collateralAmount == 0) {\n            return type(uint256).max;\n        }\n\n        uint256 collateralTokenPrice = self.priceOracle.getNormalizedPrice(self.collateralToken);\n        loanToValueRatio = self.principalAmount.div(self.collateralAmount.mul(collateralTokenPrice));\n    }\n}\n"
    },
    "contracts/libraries/CollateralToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.6;\n\nimport \"./FixedPointMath.sol\";\nimport \"./Loan.sol\";\nimport {IERC20} from \"./../interfaces/IERC20.sol\";\nimport {IPriceOracle} from \"./../interfaces/IPriceOracle.sol\";\n\nlibrary CollateralToken {\n    using FixedPointMath for uint256;\n\n    struct Data {\n        IERC20 collateralToken;\n        IPriceOracle priceOracle;\n        uint256 stabilityFee;\n        uint256 stabilizationFee;\n        uint256 exchangeFee;\n        uint256 investmentFee;\n        uint256 initialLoanToValueRatio;\n        uint256 marginCallLoanToValueRatio;\n        uint256 liquidationLoanToValueRatio;\n        uint256 collateralAmount;\n    }\n\n    uint256 internal constant ONE = 100e16;\n\n    function calculateLoanByPrincipalAmount(Data memory self, uint256 principalAmount)\n        public\n        view\n        returns (Loan.Data memory)\n    {\n        uint256 collateralTokenPrice = self.priceOracle.getNormalizedPrice(self.collateralToken);\n\n        uint256 restOfIssuance = principalAmount.mul(ONE - self.initialLoanToValueRatio).div(\n            self.initialLoanToValueRatio\n        );\n        uint256 stabilizationFee = restOfIssuance.mul(self.stabilizationFee);\n        uint256 exchangeFee = restOfIssuance.mul(self.exchangeFee);\n        uint256 investmentFee = restOfIssuance.mul(self.investmentFee);\n\n        uint256 collateralAmount = principalAmount.div(self.initialLoanToValueRatio.mul(collateralTokenPrice));\n        uint256 stabilityFee = self.stabilityFee.mul(principalAmount).div(collateralTokenPrice);\n\n        return\n            Loan.Data({\n                isActive: true,\n                collateralToken: self.collateralToken,\n                priceOracle: self.priceOracle,\n                stabilityFee: stabilityFee,\n                stabilizationFee: stabilizationFee,\n                exchangeFee: exchangeFee,\n                investmentFee: investmentFee,\n                principalAmount: principalAmount,\n                collateralAmount: collateralAmount,\n                lastDepositAt: block.timestamp,\n                lastRepaymentAt: block.timestamp\n            });\n    }\n\n    function calculateLoanByCollateralAmount(Data memory self, uint256 collateralAmount)\n        public\n        view\n        returns (Loan.Data memory)\n    {\n        uint256 collateralTokenPrice = self.priceOracle.getNormalizedPrice(self.collateralToken);\n        uint256 principalAmount = collateralAmount.mul(self.initialLoanToValueRatio).mul(collateralTokenPrice);\n\n        uint256 restOfIssuance = principalAmount.mul(ONE - self.initialLoanToValueRatio).div(\n            self.initialLoanToValueRatio\n        );\n        uint256 stabilizationFee = restOfIssuance.mul(self.stabilizationFee);\n        uint256 exchangeFee = restOfIssuance.mul(self.exchangeFee);\n        uint256 investmentFee = restOfIssuance.mul(self.investmentFee);\n\n        uint256 stabilityFee = self.stabilityFee.mul(principalAmount).div(collateralTokenPrice);\n\n        return\n            Loan.Data({\n                isActive: true,\n                collateralToken: self.collateralToken,\n                priceOracle: self.priceOracle,\n                stabilityFee: stabilityFee,\n                stabilizationFee: stabilizationFee,\n                exchangeFee: exchangeFee,\n                investmentFee: investmentFee,\n                principalAmount: principalAmount,\n                collateralAmount: collateralAmount,\n                lastDepositAt: block.timestamp,\n                lastRepaymentAt: block.timestamp\n            });\n    }\n\n    function getCollateralValue(Data memory self) internal view returns (uint256 collateralValue) {\n        uint256 collateralTokenPrice = self.priceOracle.getNormalizedPrice(self.collateralToken);\n        collateralValue = self.collateralAmount.mul(collateralTokenPrice);\n    }\n}\n"
    },
    "contracts/CoinsSafe.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.6;\n\nimport \"./libraries/AmountNormalization.sol\";\nimport \"./libraries/CollateralToken.sol\";\nimport \"./libraries/EnumerableAddressSet.sol\";\nimport \"./libraries/FixedPointMath.sol\";\nimport \"./libraries/Loan.sol\";\nimport \"./libraries/Math.sol\";\nimport \"./libraries/ReentrancyGuard.sol\";\nimport \"./libraries/SafeERC20.sol\";\nimport {Governed} from \"./Governance.sol\";\nimport {IERC20, IMintableAndBurnableERC20} from \"./interfaces/IERC20.sol\";\nimport {IPriceOracle} from \"./interfaces/IPriceOracle.sol\";\n\n/// @dev Thrown when trying to list collateral token that has zero decimals.\n/// @param token The address of the collateral token contract.\nerror CoinsSafeCollateralTokenZeroDecimals(IERC20 token);\n\n/// @dev Thrown when trying to list collateral token that has too large decimals.\n/// @param token The address of the collateral token contract.\nerror CoinsSafeCollateralTokenTooLargeDecimals(IERC20 token, uint8 decimals);\n\n/// @dev Thrown when trying to list collateral token that's already listed.\n/// @param token The address of the collateral token contract.\nerror CoinsSafeCollateralTokenAlreadyListed(IERC20 token);\n\n/// @dev Thrown when trying to unlist collateral token that's not listed.\n/// @param token The address of the collateral token contract.\nerror CoinsSafeCollateralTokenNotListed(IERC20 token);\n\n/// @dev Thrown when interacting with a token that's not allowed as collateral.\n/// @param token The address of the collateral token contract.\nerror CoinsSafeTokenNotAllowedAsCollateral(IERC20 token);\n\n/// @dev Thrown when trying to set initial loan-to-value ratio that higher than margin call or liquidation ones.\n/// @param token The address of the collateral token contract.\n/// @param initialLoanToValueRatio The initial loan-to-value ratio that was tried to set.\nerror CoinsSafeInitialLoanToValueRatioTooHigh(IERC20 token, uint256 initialLoanToValueRatio);\n\n/// @dev Thrown when trying to interact with inactive loan.\nerror CoinsSafeInactiveLoan(IERC20 token);\n\n/// @dev Thrown when trying to borrow on active loan.\nerror CoinsSafeActiveLoan(IERC20 token);\n\n/// @dev Thrown when borrowing a zero amount of stablecoin.\nerror CoinsSafeBorrowZeroAmount();\n\n/// @dev Thrown when depositing a zero amount of collateral token.\nerror CoinsSafeDepositZeroAmount();\n\n/// @notice Thrown when repaying a zero amount of stablecoin.\nerror CoinsSafeRepayZeroAmount();\n\n/// @notice Thrown when there's no need to rebalance the platform.\nerror CoinsSafeNoNeedToRebalance();\n\n/// @title Core smart contract of CoinSafe platform\n/// @author Andrey Gulitsky\n/// @notice You should use this contract to interact with the CoinsSafe platform.\n/// @notice Only this contract can issue stablecoins.\ncontract CoinsSafe is Governed, ReentrancyGuard {\n    using AmountNormalization for IERC20;\n    using CollateralToken for CollateralToken.Data;\n    using EnumerableAddressSet for EnumerableAddressSet.Set;\n    using FixedPointMath for uint256;\n    using Loan for Loan.Data;\n    using SafeERC20 for IERC20;\n    using SafeERC20 for IMintableAndBurnableERC20;\n\n    uint256 internal constant ONE = 100e16;\n    uint8 internal constant DECIMALS = 18;\n    uint256 internal constant DEFAULT_STABILITY_FEE = 3e16; // 3 %\n    uint256 internal constant DEFAULT_STABILIZATION_FEE = 85e16; // 85 %\n    uint256 internal constant DEFAULT_EXCHANGE_FEE = 15e16; // 15 %\n    uint256 internal constant DEFAULT_INVESTMENT_FEE = 0;\n    uint256 internal constant DEFAULT_INITIAL_LOAN_TO_VALUE_RATIO = 70e16; // 70 %\n    uint256 internal constant DEFAULT_MARGIN_CALL_LOAN_TO_VALUE_RATIO = 75e16; // 75 %\n    uint256 internal constant DEFAULT_LIQUIDATION_LOAN_TO_VALUE_RATIO = 83e16; // 83 %\n    uint256 internal constant REBALANCING_THRESHOLD = 1e16; // 1 %\n\n    IMintableAndBurnableERC20 public immutable stablecoin;\n    IPriceOracle public immutable priceOracle;\n\n    address public immutable operator;\n    address public immutable exchangeFund;\n    address public immutable investmentFund;\n\n    mapping(address => mapping(IERC20 => Loan.Data)) public loans;\n\n    mapping(IERC20 => CollateralToken.Data) public collateralTokens;\n    EnumerableAddressSet.Set internal collateralTokensSet;\n\n    event CollateralTokenListed(IERC20 indexed token);\n    event CollateralTokenUnlisted(IERC20 indexed token);\n\n    event InitialLoanToValueRatioUpdated(\n        IERC20 indexed token,\n        uint256 initialLoanToValueRatio,\n        uint256 newInitialLoanToValueRatio\n    );\n\n    event Borrow(\n        address indexed borrower,\n        IERC20 indexed token,\n        uint256 principalAmount,\n        uint256 collateralAmount,\n        uint256 initialLoanToValueRatio\n    );\n    event Deposit(address indexed borrower, IERC20 indexed token, uint256 collateralAmount);\n    event Repay(address indexed borrower, IERC20 indexed token, uint256 principalAmount);\n    event Repaid(address indexed borrower, IERC20 indexed token);\n\n    event Rebalance(int256 delta);\n\n    modifier tokenAllowedAsCollateral(IERC20 token) {\n        if (!collateralTokensSet.contains(address(token))) {\n            revert CoinsSafeTokenNotAllowedAsCollateral(token);\n        }\n        _;\n    }\n\n    modifier onInactiveLoan(IERC20 token) {\n        if (loans[msg.sender][token].isActive) {\n            revert CoinsSafeActiveLoan(token);\n        }\n        _;\n    }\n\n    modifier onActiveLoan(IERC20 token) {\n        if (!loans[msg.sender][token].isActive) {\n            revert CoinsSafeInactiveLoan(token);\n        }\n        _;\n    }\n\n    constructor(\n        IMintableAndBurnableERC20 _stablecoin,\n        IPriceOracle _priceOracle,\n        address _operator,\n        address _exchangeFund,\n        address _investmentFund\n    ) {\n        stablecoin = _stablecoin;\n        priceOracle = _priceOracle;\n        operator = _operator;\n        exchangeFund = _exchangeFund;\n        investmentFund = _investmentFund;\n    }\n\n    /// @notice Increases loan's principal on `collateralToken` collateral token and mints `amount` of stablecoin.\n    /// @dev The caller must have allowed this contract to spend a sufficient amount of collateral tokens to cover\n    /// initial loan-to-value ratio.\n    /// @param collateralToken The address of the collateral token contract.\n    /// @param amount The amount of stablecoin to borrow and issue.\n    function borrow(IERC20 collateralToken, uint256 amount)\n        external\n        nonReentrant\n        tokenAllowedAsCollateral(collateralToken)\n        onInactiveLoan(collateralToken)\n        returns (Loan.Data memory)\n    {\n        if (amount == 0) {\n            revert CoinsSafeBorrowZeroAmount();\n        }\n\n        Loan.Data memory loan = collateralTokens[collateralToken].calculateLoanByPrincipalAmount(amount);\n\n        uint256 denormalizedStabilityFee = collateralToken.denormalizeAmount(loan.stabilityFee);\n        collateralToken.safeTransferFrom(msg.sender, operator, denormalizedStabilityFee);\n\n        uint256 denormalizedCollateralAmount = collateralToken.denormalizeAmount(loan.collateralAmount);\n        collateralToken.safeTransferFrom(msg.sender, address(this), denormalizedCollateralAmount);\n\n        stablecoin.mint(address(this), loan.stabilizationFee);\n        stablecoin.mint(exchangeFund, loan.exchangeFee);\n        stablecoin.mint(investmentFund, loan.investmentFee);\n        stablecoin.mint(msg.sender, amount);\n\n        loans[msg.sender][collateralToken] = loan;\n        collateralTokens[collateralToken].collateralAmount += loan.collateralAmount;\n\n        emit Borrow(\n            msg.sender,\n            collateralToken,\n            amount,\n            loan.collateralAmount,\n            collateralTokens[collateralToken].initialLoanToValueRatio\n        );\n\n        return loan;\n    }\n\n    /// @notice Deposits `amount` of collateral token to loan.\n    /// @dev The caller must have allowed this contract to spend `amount` of collateral tokens.\n    /// @param collateralToken The address of the collateral token contract.\n    /// @param amount The amount of collateral token to deposit.\n    function deposit(IERC20 collateralToken, uint256 amount)\n        external\n        nonReentrant\n        tokenAllowedAsCollateral(collateralToken)\n        onActiveLoan(collateralToken)\n    {\n        if (amount == 0) {\n            revert CoinsSafeDepositZeroAmount();\n        }\n\n        collateralToken.safeTransferFrom(msg.sender, address(this), amount);\n\n        Loan.Data storage loan = loans[msg.sender][collateralToken];\n        uint256 normalizedCollateralAmount = collateralToken.normalizeAmount(amount);\n        loan.collateralAmount += normalizedCollateralAmount;\n        loan.lastDepositAt = block.timestamp;\n        collateralTokens[collateralToken].collateralAmount += normalizedCollateralAmount;\n\n        emit Deposit(msg.sender, collateralToken, normalizedCollateralAmount);\n    }\n\n    /// @notice Decreases loan's principal on `collateralToken` collateral token by `amount` of stablecoin..\n    /// @param collateralToken The address of the collateral token contract.\n    /// @param amount The amount of stablecoin to repay.\n    function repay(IERC20 collateralToken, uint256 amount)\n        external\n        nonReentrant\n        tokenAllowedAsCollateral(collateralToken)\n        onActiveLoan(collateralToken)\n    {\n        if (amount == 0) {\n            revert CoinsSafeRepayZeroAmount();\n        }\n\n        Loan.Data storage loan = loans[msg.sender][collateralToken];\n        loan.principalAmount -= amount;\n\n        if (loan.principalAmount > 0) {\n            stablecoin.safeTransferFrom(msg.sender, address(this), amount);\n            loan.lastRepaymentAt = block.timestamp;\n            emit Repay(msg.sender, collateralToken, amount);\n        } else {\n            collateralTokens[collateralToken].collateralAmount -= loan.collateralAmount;\n            collateralToken.safeTransfer(msg.sender, collateralToken.denormalizeAmount(loan.collateralAmount));\n\n            stablecoin.burn(msg.sender, amount);\n            stablecoin.burn(address(this), loan.stabilizationFee);\n\n            delete loans[msg.sender][collateralToken];\n\n            emit Repaid(msg.sender, collateralToken);\n        }\n    }\n\n    function rebalance() external nonReentrant {\n        uint256 collateralValue;\n        for (uint256 i = 0; i < collateralTokensSet.elements.length; i++) {\n            collateralValue += collateralTokens[IERC20(collateralTokensSet.elements[i])].getCollateralValue();\n        }\n\n        uint256 totalSupply = stablecoin.totalSupply();\n        int256 delta = int256(totalSupply) - int256(collateralValue);\n        uint256 absoluteDelta = Math.abs(delta);\n        uint256 p = absoluteDelta.div(totalSupply);\n        if (p < REBALANCING_THRESHOLD) {\n            revert CoinsSafeNoNeedToRebalance();\n        }\n        if (delta > 0) {\n            stablecoin.burn(address(this), absoluteDelta);\n        } else {\n            stablecoin.mint(address(this), absoluteDelta);\n        }\n        emit Rebalance(delta);\n    }\n\n    function listCollateralToken(IERC20 token, uint256 initialLoanToValueRatio) external onlyGovernor {\n        if (collateralTokensSet.contains(address(token))) {\n            revert CoinsSafeCollateralTokenAlreadyListed(token);\n        }\n\n        if (initialLoanToValueRatio >= DEFAULT_MARGIN_CALL_LOAN_TO_VALUE_RATIO) {\n            revert CoinsSafeInitialLoanToValueRatioTooHigh(token, initialLoanToValueRatio);\n        }\n\n        uint8 decimals = token.decimals();\n        if (decimals == 0) {\n            revert CoinsSafeCollateralTokenZeroDecimals(token);\n        }\n        if (decimals > DECIMALS) {\n            revert CoinsSafeCollateralTokenTooLargeDecimals(token, decimals);\n        }\n\n        if (collateralTokensSet.add(address(token))) {\n            collateralTokens[token] = CollateralToken.Data({\n                collateralToken: token,\n                priceOracle: priceOracle,\n                stabilityFee: DEFAULT_STABILITY_FEE,\n                stabilizationFee: DEFAULT_STABILIZATION_FEE,\n                exchangeFee: DEFAULT_EXCHANGE_FEE,\n                investmentFee: DEFAULT_INVESTMENT_FEE,\n                initialLoanToValueRatio: initialLoanToValueRatio,\n                marginCallLoanToValueRatio: DEFAULT_MARGIN_CALL_LOAN_TO_VALUE_RATIO,\n                liquidationLoanToValueRatio: DEFAULT_LIQUIDATION_LOAN_TO_VALUE_RATIO,\n                collateralAmount: 0\n            });\n\n            emit CollateralTokenListed(token);\n            emit InitialLoanToValueRatioUpdated(token, 0, initialLoanToValueRatio);\n        }\n    }\n\n    function unlistCollateralToken(IERC20 token) external onlyGovernor {\n        if (!collateralTokensSet.contains(address(token))) {\n            revert CoinsSafeCollateralTokenNotListed(token);\n        }\n\n        if (collateralTokensSet.remove(address(token))) {\n            delete collateralTokens[token];\n            emit CollateralTokenUnlisted(token);\n        }\n    }\n\n    function setInitialLoanToValueRatio(IERC20 token, uint256 newInitialLoanToValueRatio) external onlyGovernor {\n        if (!collateralTokensSet.contains(address(token))) {\n            revert CoinsSafeCollateralTokenNotListed(token);\n        }\n\n        CollateralToken.Data storage collateralToken = collateralTokens[token];\n        if (newInitialLoanToValueRatio >= collateralToken.marginCallLoanToValueRatio) {\n            revert CoinsSafeInitialLoanToValueRatioTooHigh(token, newInitialLoanToValueRatio);\n        }\n\n        uint256 initialLoanToValueRatio = collateralToken.initialLoanToValueRatio;\n        collateralToken.initialLoanToValueRatio = newInitialLoanToValueRatio;\n\n        emit InitialLoanToValueRatioUpdated(token, initialLoanToValueRatio, newInitialLoanToValueRatio);\n    }\n\n    function getLoans() external view returns (Loan.Data[] memory _loans) {\n        uint256 length = collateralTokensSet.elements.length;\n        _loans = new Loan.Data[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            _loans[i] = loans[msg.sender][IERC20(collateralTokensSet.elements[i])];\n        }\n    }\n\n    function getAllowedCollateralTokens()\n        external\n        view\n        returns (CollateralToken.Data[] memory allowedCollateralTokens)\n    {\n        uint256 length = collateralTokensSet.elements.length;\n        allowedCollateralTokens = new CollateralToken.Data[](length);\n\n        for (uint256 i = 0; i < length; i++) {\n            allowedCollateralTokens[i] = collateralTokens[IERC20(collateralTokensSet.elements[i])];\n        }\n    }\n\n    function getLoanToValueRatio(IERC20 collateralToken) external view returns (uint256 loanToValueRatio) {\n        Loan.Data memory loan = loans[msg.sender][collateralToken];\n        loanToValueRatio = loan.calculateLoanToValueRatio();\n    }\n\n    function calculateLoanByPrincipalAmount(IERC20 collateralToken, uint256 principalAmount)\n        external\n        view\n        returns (Loan.Data memory loan)\n    {\n        loan = collateralTokens[collateralToken].calculateLoanByPrincipalAmount(principalAmount);\n    }\n\n    function calculateLoanByCollateralAmount(IERC20 collateralToken, uint256 collateralAmount)\n        external\n        view\n        returns (Loan.Data memory loan)\n    {\n        loan = collateralTokens[collateralToken].calculateLoanByCollateralAmount(collateralAmount);\n    }\n}\n"
    },
    "contracts/libraries/AmountNormalization.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.6;\n\nimport \"./../interfaces/IERC20.sol\";\n\nlibrary AmountNormalization {\n    uint8 internal constant DECIMALS = 18;\n\n    function normalizeAmount(IERC20 self, uint256 denormalizedAmount) internal view returns (uint256 normalizedAmount) {\n        uint256 scale = 10**(DECIMALS - self.decimals());\n        if (scale != 1) {\n            return denormalizedAmount * scale;\n        }\n        return denormalizedAmount;\n    }\n\n    function denormalizeAmount(IERC20 self, uint256 normalizedAmount)\n        internal\n        view\n        returns (uint256 denormalizedAmount)\n    {\n        uint256 scale = 10**(DECIMALS - self.decimals());\n        if (scale != 1) {\n            return normalizedAmount / scale;\n        }\n        return normalizedAmount;\n    }\n}\n"
    },
    "contracts/libraries/EnumerableAddressSet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.6;\n\nlibrary EnumerableAddressSet {\n    struct Set {\n        address[] elements;\n        mapping(address => uint256) indexes;\n    }\n\n    function add(Set storage self, address element) internal returns (bool) {\n        if (contains(self, element)) {\n            return false;\n        }\n\n        self.elements.push(element);\n        self.indexes[element] = self.elements.length;\n\n        return true;\n    }\n\n    function remove(Set storage self, address element) internal returns (bool) {\n        uint256 elementIndex = indexOf(self, element);\n        if (elementIndex == 0) {\n            return false;\n        }\n\n        uint256 indexToRemove = elementIndex - 1;\n        uint256 lastIndex = count(self) - 1;\n        if (indexToRemove != lastIndex) {\n            address lastElement = self.elements[lastIndex];\n            self.elements[indexToRemove] = lastElement;\n            self.indexes[lastElement] = elementIndex;\n        }\n        self.elements.pop();\n        delete self.indexes[element];\n\n        return true;\n    }\n\n    function indexOf(Set storage self, address element) internal view returns (uint256) {\n        return self.indexes[element];\n    }\n\n    function contains(Set storage self, address element) internal view returns (bool) {\n        return indexOf(self, element) != 0;\n    }\n\n    function count(Set storage self) internal view returns (uint256) {\n        return self.elements.length;\n    }\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nlibrary Math {\n    function abs(int256 a) internal pure returns (uint256) {\n        return a >= 0 ? uint256(a) : uint256(-a);\n    }\n}\n"
    },
    "contracts/libraries/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.6;\n\nerror ReentrancyGuardReentrantCall();\n\nabstract contract ReentrancyGuard {\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private status;\n\n    modifier nonReentrant() {\n        if (status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        status = ENTERED;\n\n        _;\n\n        status = NOT_ENTERED;\n    }\n\n    constructor() {\n        status = NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.6;\n\nimport \"./../interfaces/IERC20.sol\";\nimport \"./Address.sol\";\n\nerror SafeERC20NoReturnData();\n\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        callWithOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, amount));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        callWithOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, amount));\n    }\n\n    function callWithOptionalReturn(IERC20 token, bytes memory data) internal {\n        address tokenAddress = address(token);\n\n        bytes memory returnData = tokenAddress.functionCall(data, \"SafeERC20LowLevelCall\");\n        if (returnData.length > 0) {\n            if (!abi.decode(returnData, (bool))) {\n                revert SafeERC20NoReturnData();\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/Address.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.6;\n\nerror CallToNonContract(address target);\n\nlibrary Address {\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        if (!isContract(target)) {\n            revert CallToNonContract(target);\n        }\n\n        (bool success, bytes memory returnData) = target.call(data);\n        if (success) {\n            return returnData;\n        } else {\n            if (returnData.length > 0) {\n                assembly {\n                    let returnDataSize := mload(returnData)\n                    revert(add(returnData, 32), returnDataSize)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n\n    function isContract(address account) internal view returns (bool) {\n        uint256 codeSize;\n        assembly {\n            codeSize := extcodesize(account)\n        }\n\n        return codeSize > 0;\n    }\n}\n"
    },
    "contracts/InvestmentFund.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.6;\n\nimport {Governed} from \"./Governance.sol\";\n\ncontract InvestmentFund is Governed {}\n"
    },
    "contracts/ExchangeFund.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.6;\n\nimport {Governed} from \"./Governance.sol\";\n\ncontract ExchangeFund is Governed {}\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 800
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    }
  }
}
